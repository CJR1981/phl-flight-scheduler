<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PHL Flight Scheduler</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: white;
            border-radius: 12px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            overflow: hidden;
        }

        .header {
            background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%);
            color: white;
            padding: 30px;
            text-align: center;
        }

        .header h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
        }

        .header p {
            font-size: 1.1em;
            opacity: 0.9;
        }

        .content {
            padding: 30px;
        }

        .upload-section {
            background: #f8f9fa;
            border-radius: 8px;
            padding: 25px;
            margin-bottom: 25px;
        }

        .upload-section h2 {
            color: #2a5298;
            margin-bottom: 20px;
            font-size: 1.5em;
        }

        .file-upload-group {
            margin-bottom: 20px;
        }

        .file-upload-group label {
            display: block;
            font-weight: 600;
            margin-bottom: 8px;
            color: #495057;
        }

        .file-input-wrapper {
            position: relative;
            display: inline-block;
            width: 100%;
        }

        .file-input-wrapper input[type="file"] {
            width: 100%;
            padding: 12px;
            border: 2px dashed #cbd5e0;
            border-radius: 6px;
            background: white;
            cursor: pointer;
            transition: all 0.3s;
        }

        .file-input-wrapper input[type="file"]:hover {
            border-color: #667eea;
            background: #f7fafc;
        }

        .file-status {
            margin-top: 8px;
            font-size: 0.9em;
            color: #28a745;
            font-weight: 500;
        }

        .button-group {
            display: flex;
            gap: 15px;
            margin-top: 25px;
            flex-wrap: wrap;
        }

        button {
            padding: 14px 28px;
            font-size: 1em;
            font-weight: 600;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.3s;
            display: inline-flex;
            align-items: center;
            gap: 8px;
        }

        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .btn-primary {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }

        .btn-primary:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.4);
        }

        .btn-success {
            background: linear-gradient(135deg, #28a745 0%, #20c997 100%);
            color: white;
        }

        .btn-success:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(40, 167, 69, 0.4);
        }

        .results-section {
            margin-top: 30px;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }

        .stat-card {
            background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);
            padding: 20px;
            border-radius: 8px;
            border-left: 4px solid #667eea;
        }

        .stat-card h3 {
            font-size: 0.9em;
            color: #6c757d;
            margin-bottom: 8px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .stat-card .value {
            font-size: 2em;
            font-weight: bold;
            color: #2a5298;
        }

        .table-container {
            overflow-x: auto;
            margin-top: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
        }

        table {
            width: 100%;
            border-collapse: collapse;
            background: white;
        }

        th {
            background: linear-gradient(135deg, #2a5298 0%, #1e3c72 100%);
            color: white;
            padding: 15px;
            text-align: left;
            font-weight: 600;
            position: sticky;
            top: 0;
            z-index: 10;
        }

        td {
            padding: 12px 15px;
            border-bottom: 1px solid #e9ecef;
        }

        tr:hover {
            background: #f8f9fa;
        }

        .status-badge {
            display: inline-block;
            padding: 4px 12px;
            border-radius: 12px;
            font-size: 0.85em;
            font-weight: 600;
        }

        .status-domestic {
            background: #d1ecf1;
            color: #0c5460;
        }

        .status-international {
            background: #fff3cd;
            color: #856404;
        }
        
        .team-selector {
            padding: 8px 12px;
            border: 2px solid #cbd5e0;
            border-radius: 6px;
            background: white;
            font-size: 0.95em;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
            min-width: 120px;
        }
        
        .team-selector:hover {
            border-color: #667eea;
            background: #f7fafc;
            box-shadow: 0 2px 4px rgba(102, 126, 234, 0.2);
        }
        
        .team-selector:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.2);
        }
        
        .team-selector option {
            padding: 8px;
        }
        
        .team-detail-card {
            background: white;
            border-radius: 8px;
            margin-bottom: 20px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
            overflow: hidden;
        }
        
        .team-detail-header {
            background: linear-gradient(135deg, #2a5298 0%, #1e3c72 100%);
            color: white;
            padding: 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
            gap: 15px;
        }
        
        .team-detail-header h3 {
            margin: 0;
            font-size: 1.5em;
        }
        
        .team-detail-info {
            display: flex;
            gap: 20px;
            flex-wrap: wrap;
            font-size: 0.95em;
        }
        
        .team-detail-info-item {
            display: flex;
            flex-direction: column;
        }
        
        .team-detail-info-item label {
            opacity: 0.8;
            font-size: 0.85em;
            margin-bottom: 2px;
        }
        
        .team-detail-info-item value {
            font-weight: 600;
        }
        
        .team-flights-table {
            width: 100%;
            border-collapse: collapse;
        }
        
        .team-flights-table th {
            background: #f8f9fa;
            color: #495057;
            padding: 12px;
            text-align: left;
            font-weight: 600;
            border-bottom: 2px solid #e9ecef;
        }
        
        .team-flights-table td {
            padding: 12px;
            border-bottom: 1px solid #e9ecef;
        }
        
        .team-flights-table tr:hover {
            background: #f8f9fa;
        }
        
        .team-flights-table tr:last-child td {
            border-bottom: none;
        }
        
        .flight-detail-badge {
            display: inline-block;
            padding: 3px 8px;
            border-radius: 4px;
            font-size: 0.85em;
            font-weight: 600;
            margin-right: 5px;
        }
        
        .overnight-card .team-detail-header {
            background: linear-gradient(135deg, #ffc107 0%, #ff9800 100%);
            color: #000;
        }

        .loading {
            display: none;
            text-align: center;
            padding: 40px;
        }

        .loading.active {
            display: block;
        }

        .spinner {
            border: 4px solid #f3f3f3;
            border-top: 4px solid #667eea;
            border-radius: 50%;
            width: 50px;
            height: 50px;
            animation: spin 1s linear infinite;
            margin: 0 auto 20px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .alert {
            padding: 15px 20px;
            border-radius: 6px;
            margin-bottom: 20px;
        }

        .alert-info {
            background: #d1ecf1;
            border-left: 4px solid #0c5460;
            color: #0c5460;
        }

        .alert-warning {
            background: #fff3cd;
            border-left: 4px solid #856404;
            color: #856404;
        }

        .alert-success {
            background: #d4edda;
            border-left: 4px solid #155724;
            color: #155724;
        }

        .section-title {
            font-size: 1.3em;
            color: #2a5298;
            margin: 30px 0 15px;
            padding-bottom: 10px;
            border-bottom: 2px solid #e9ecef;
        }

        .workload-bar {
            height: 20px;
            background: #e9ecef;
            border-radius: 10px;
            overflow: hidden;
        }

        .workload-fill {
            height: 100%;
            background: linear-gradient(90deg, #28a745 0%, #20c997 50%, #ffc107 80%, #dc3545 100%);
            transition: width 0.3s;
        }

        @media (max-width: 768px) {
            .header h1 {
                font-size: 1.8em;
            }
            
            .stats-grid {
                grid-template-columns: 1fr;
            }
            
            .button-group {
                flex-direction: column;
            }
            
            button {
                width: 100%;
                justify-content: center;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>‚úàÔ∏è PHL Flight Scheduler</h1>
            <p>Philadelphia International Airport - Catering Operations Scheduler</p>
        </div>

        <div class="content">
            <div class="upload-section">
                <h2>üìÖ Daily Schedule Configuration</h2>
                
                <div class="alert alert-info" style="margin-bottom: 20px;">
                    <strong>‚ÑπÔ∏è Agent Schedules Pre-Loaded</strong><br>
                    Full-time and part-time agent schedules are built into the system. Simply select the day and upload the flight schedule.
                </div>
                
                <div class="file-upload-group">
                    <label for="dayOfWeek">Select Day of Week to Schedule</label>
                    <select id="dayOfWeek" style="width: 100%; padding: 12px; border: 2px solid #cbd5e0; border-radius: 6px; font-size: 1em; background: white;">
                        <option value="Monday">Monday</option>
                        <option value="Tuesday">Tuesday</option>
                        <option value="Wednesday">Wednesday</option>
                        <option value="Thursday" selected>Thursday</option>
                        <option value="Friday">Friday</option>
                        <option value="Saturday">Saturday</option>
                        <option value="Sunday">Sunday</option>
                    </select>
                </div>

                <div class="file-upload-group">
                    <label for="flights">Daily Flight Schedule (CSV)</label>
                    <div class="file-input-wrapper">
                        <input type="file" id="flights" accept=".csv" />
                    </div>
                    <div class="file-status" id="flightStatus"></div>
                </div>

                <div class="button-group">
                    <button class="btn-primary" id="generateBtn" disabled>
                        üöÄ Generate Schedule
                    </button>
                    <button class="btn-success" id="exportBtn" disabled>
                        üìä Export to Excel
                    </button>
                </div>
            </div>

            <div class="loading" id="loading">
                <div class="spinner"></div>
                <p>Generating optimized schedule...</p>
            </div>

            <div class="results-section" id="results" style="display: none;">
                <h2 class="section-title">üìä Schedule Summary</h2>
                <div class="stats-grid" id="statsGrid"></div>

                <h2 class="section-title">üë• Team Assignments Summary</h2>
                <div class="table-container">
                    <table id="teamTable">
                        <thead>
                            <tr>
                                <th>Team</th>
                                <th>Shift</th>
                                <th>Operations</th>
                                <th>Workload</th>
                                <th>Flights</th>
                                <th>First Flight</th>
                                <th>Last Flight</th>
                                <th>Finish Time</th>
                            </tr>
                        </thead>
                        <tbody id="teamTableBody"></tbody>
                    </table>
                </div>

                <h2 class="section-title">üìã Detailed Team Assignments (Grouped by Team)</h2>
                <div id="teamDetailedGroups"></div>

                <h2 class="section-title">üõ´ All Flight Assignments (Chronological)</h2>
                <div class="table-container">
                    <table id="flightTable">
                        <thead>
                            <tr>
                                <th>Flight</th>
                                <th>Destination</th>
                                <th>Departure Time</th>
                                <th>Type</th>
                                <th>Assigned Team</th>
                                <th>Gate</th>
                            </tr>
                        </thead>
                        <tbody id="flightTableBody"></tbody>
                    </table>
                </div>

                <div id="unassignedSection" style="display: none;">
                    <h2 class="section-title">‚ö†Ô∏è Unassigned Flights</h2>
                    <div class="alert alert-warning" id="unassignedAlert"></div>
                    <div class="table-container">
                        <table id="unassignedTable">
                            <thead>
                                <tr>
                                    <th>Flight</th>
                                    <th>Origin</th>
                                    <th>Time</th>
                                    <th>Type</th>
                                    <th>Reason</th>
                                </tr>
                            </thead>
                            <tbody id="unassignedTableBody"></tbody>
                        </table>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // ==================== HARDCODED AGENT SCHEDULES ====================
        // These are loaded automatically - updated quarterly
        const FT_AGENTS_CSV = `AA ID,Last Name,First Name,LN#,LineType,Monday,Mon Department,Mon Team,Tuesday,Tues Department,Tues Team,Wednesday,Wed Department,Wed Team,Thursday,Thurs Department,Thurs Team,Friday,Fri Department,Fri Team,Saturday,Sat Department,Sat Team,Sunday,Sun Department,Sun Team,__PowerAppsId__
921303,Nunez,Abel,9254,Regular,1300-2130,U30 TRK,TM211,1300-2130,U30 TRK,TM211,1300-2130,U30 TRK,TM212,1300-2130,U30 TRK,TM212,1300-2130,U30 TRK,TM220,Off,,,Off,,,76d75b4e-996e-4dfd-8a72-57ad2b82a337
583128,Dahn,Abraham,9210,Regular,0500-1330,U30 TRK,TM204,0500-1330,U30 TRK,TM204,0500-1330,U30 TRK,TM204,0500-1330,U30 TRK,TM204,0500-1330,U30 TRK,TM204,Off,,,Off,,,80655a97-0ce9-4d7f-87d4-5e1e0a9edb69
229132,Branch,Acquil,9264,Regular,1400-2230,U30 TRK,TM224,1400-2230,U30 TRK,TM224,1400-2230,U30 TRK,TM224,1400-2230,U30 TRK,TM224,Off,,,Off,,,1400-2230,U30 TRK,TM224,136c2c45-d218-4f67-b457-285b44d79393
543150,Jarquin-Monge,Alejandro,9206,Regular,0500-1330,U30 TRK,TM202,Off,,,Off,,,0500-1330,U30 TRK,TM202,0500-1330,U30 TRK,TM202,0500-1330,U30 TRK,TM202,0500-1330,U30 TRK,TM202,aa6892db-7fc5-4452-b386-31749925b0d4
920934,Jones,Alexander,9230,Regular,Off,,,Off,,,1300-2130,U30 TRK,TM211,1300-2130,U30 TRK,TM211,1300-2130,U30 TRK,TM211,1300-2130,U30 TRK,TM211,1300-2130,U30 TRK,TM211,c404b21a-d2ce-40a2-80c3-8cb87cc45d0d
920919,Alexander,Andrew,9244,Regular,Off,,,Off,,,1300-2130,U30 TRK,TM219,1300-2130,U30 TRK,TM219,1300-2130,U30 TRK,TM219,1300-2130,U30 TRK,TM219,1300-2130,U30 TRK,TM219,8e9bdef8-a9c0-4d34-afab-4645b2cfe9f0
469168,Mosley,Andrew,9250,Regular,1300-2130,U30 TRK,TM215,1300-2130,U30 TRK,TM216,1300-2130,U30 TRK,TM216,1300-2130,U30 TRK,TM217,Off,,,Off,,,1300-2130,U30 TRK,TM215,ffb26d17-d157-44a4-bf5f-718cc53b0bdb
953237,Jordan,Angel,9263,Regular,1400-2230,U30 TRK,TM223,1400-2230,U30 TRK,TM223,Off,,,Off,,,1400-2230,U30 TRK,TM224,1400-2230,U30 TRK,TM224,1400-2230,U30 TRK,TM224,8e473fa3-2179-4d9b-b9ef-6eafaf26674f
208708,Valcarcel,Angelo,9251,Variable,1200-2030,U30 TRK,TM210,Off,,,Off,,,1300-2130,U30 TRK,TM220,1300-2130,U30 TRK,TM214,1300-2130,U30 TRK,TM214,1200-2030,U30 TRK,TM210,510571e9-1919-4db4-af0a-b4ac8c62a7a3
100316,Banks,Antonio,9213,Regular,0600-1430,U30 TRK,TM206,0600-1430,U30 TRK,TM206,0600-1430,U30 TRK,TM206,Off,,,Off,,,0600-1430,U30 TRK,TM206,0600-1430,U30 TRK,TM206,5204a81f-a254-4c6d-ba55-e8e8e1a2ca56
856584,Ammishaddai,Asher,9232,Regular,1300-2130,U30 TRK,TM212,1300-2130,U30 TRK,TM212,Off,,,Off,,,1300-2130,U30 TRK,TM212,1300-2130,U30 TRK,TM212,1300-2130,U30 TRK,TM212,112656af-7c51-477f-aa8c-ee070271ce3e
902769,Sam,Bryan,9231,Regular,1300-2130,U30 TRK,TM212,1300-2130,U30 TRK,TM212,Off,,,Off,,,1300-2130,U30 TRK,TM212,1300-2130,U30 TRK,TM212,1300-2130,U30 TRK,TM212,db331175-44a5-443f-b912-438299fa505f
140196,Palmer,Christopher,9216,Regular,Off,,,0700-1530,U30 TRK,TM207,0700-1530,U30 TRK,TM207,0700-1530,U30 TRK,TM207,0700-1530,U30 TRK,TM207,0700-1530,U30 TRK,TM207,Off,,,0e9d721d-f8cb-4888-b9fc-5db8d2bedd76
902755,Thomas,Clarence,9252,Variable,1200-2030,U30 TRK,TM210,Off,,,Off,,,1300-2130,U30 TRK,TM220,1300-2130,U30 TRK,TM214,1300-2130,U30 TRK,TM214,1200-2030,U30 TRK,TM210,51d553f1-4261-4228-b7ad-8f4877ab0fc6
145706,Hill,Clarence,9261,Regular,1400-2230,U30 TRK,TM223,1400-2230,U30 TRK,TM223,1400-2230,U30 TRK,TM223,1400-2230,U30 TRK,TM223,1400-2230,U30 TRK,TM223,Off,,,Off,,,96452a80-910d-4c4a-bcbb-de1a28bfd215
192872,Nguyen,Daniel,9211,Regular,Off,,,Off,,,0600-1430,U30 TRK,TM205,0600-1430,U30 TRK,TM205,0600-1430,U30 TRK,TM205,0600-1430,U30 TRK,TM205,0600-1430,U30 TRK,TM205,20852fcb-b23d-419c-b3e1-022c47df9aba
774531,Boyer,Darnell,9235,Regular,Off,,,1300-2130,U30 TRK,TM215,1300-2130,U30 TRK,TM215,1300-2130,U30 TRK,TM215,1300-2130,U30 TRK,TM215,1300-2130,U30 TRK,TM215,Off,,,8fd2ad9e-0708-4695-95d5-e07f03c09287
179596,White,Darryl,9221,Variable,0600-1430,U30 TRK,TM205,0600-1430,U30 TRK,TM205,0500-1330,U30 TRK,TM202,0500-1330,U30 TRK,TM203,0500-1330,U30 TRK,TM203,Off,,,Off,,,5103b608-d754-47a8-ba15-ec3420826c7b
212615,Carter,Deja,9228,Regular,Off,,,1200-2030,U30 TRK,TM210,1200-2030,U30 TRK,TM210,1200-2030,U30 TRK,TM210,1200-2030,U30 TRK,TM210,1200-2030,U30 TRK,TM210,Off,,,3792803b-6841-49ea-9ff7-f72966058e6e
237067,Hopson,Dennis,9249,Regular,1300-2130,U30 TRK,TM215,1300-2130,U30 TRK,TM216,1300-2130,U30 TRK,TM216,1300-2130,U30 TRK,TM217,Off,,,Off,,,1300-2130,U30 TRK,TM215,deda8428-a4eb-447e-893d-46959e37756e
846712,Bernal-Santos,Dilia,9253,Regular,1300-2130,U30 TRK,TM211,1300-2130,U30 TRK,TM211,1300-2130,U30 TRK,TM212,1300-2130,U30 TRK,TM212,1300-2130,U30 TRK,TM220,Off,,,Off,,,a0b4c245-70cb-4f31-b26e-2e0806fcef50
401312,Rehman,Gohar,9217,Regular,0700-1530,U30 TRK,TM208,Off,,,Off,,,0700-1530,U30 TRK,TM208,0700-1530,U30 TRK,TM208,0700-1530,U30 TRK,TM208,0700-1530,U30 TRK,TM208,fb69af55-7333-4e14-a73a-c0e3e6187b67
920940,HUA,HUMPHREY,9229,Regular,Off,,,Off,,,1300-2130,U30 TRK,TM211,1300-2130,U30 TRK,TM211,1300-2130,U30 TRK,TM211,1300-2130,U30 TRK,TM211,1300-2130,U30 TRK,TM211,03ce72a7-405c-4e2a-b326-a522f0d7753f
101115,Destina,Ivencleef,9207,Regular,0500-1330,U30 TRK,TM203,0500-1330,U30 TRK,TM203,0500-1330,U30 TRK,TM203,Off,,,Off,,,0500-1330,U30 TRK,TM203,0500-1330,U30 TRK,TM203,e90192f2-2530-43e8-b7ca-cbf5a9f5d865
797089,Everett,Jakara,9246,Regular,1300-2130,U30 TRK,TM220,1300-2130,U30 TRK,TM220,1300-2130,U30 TRK,TM220,Off,,,Off,,,1300-2130,U30 TRK,TM220,1300-2130,U30 TRK,TM220,a641ae40-d8d0-47df-853c-032525ab6ca6
101576,Coulter,Jalil,9233,Regular,1300-2130,U30 TRK,TM214,1300-2130,U30 TRK,TM214,1300-2130,U30 TRK,TM214,1300-2130,U30 TRK,TM214,Off,,,Off,,,1300-2130,U30 TRK,TM214,a062fb84-9fcf-42ef-b3a7-dc93c705328e
540462,West,Jamal,9225,Regular,0700-1530,U30 TRK,TM207,0700-1530,U30 TRK,TM208,0700-1530,U30 TRK,TM208,Off,,,Off,,,0700-1530,U30 CAT,FSA,0700-1530,U30 TRK,TM207,3327d36e-f4f1-498e-a817-07e7931efc82
296349,Jackson,Jaquione,9242,Regular,1300-2130,U30 TRK,TM218,1300-2130,U30 TRK,TM218,1300-2130,U30 TRK,TM218,1300-2130,U30 TRK,TM218,1300-2130,U30 TRK,TM218,Off,,,Off,,,d488ae0c-38e8-4f61-9ff2-fc0d14b23643
467137,Anderson,Jermele,9204,Regular,0400-1230,U30 TRK,TM201,0400-1230,U30 TRK,TM201,0400-1230,U30 TRK,TM201,0400-1230,U30 TRK,TM201,Off,,,Off,,,0400-1230,U30 TRK,TM201,9cd8900a-ac75-4646-ac32-c5447749fc83
442863,Austin,Jessica,9219,Variable,0300-1130,U30 TRK,TM200,0500-1330,U30 TRK,TM202,Off,,,Off,,,0400-1230,U30 TRK,TM201,0400-1230,U30 TRK,TM201,0300-1130,U30 TRK,TM200,67b4ddce-0f61-4d9a-9217-c5966d66a0b7
597525,Lewis-Wise,John,9220,Variable,0300-1130,U30 TRK,TM200,0500-1330,U30 TRK,TM202,Off,,,Off,,,0400-1230,U30 TRK,TM201,0400-1230,U30 TRK,TM201,0300-1130,U30 TRK,TM200,906281e8-6e21-4744-b485-ac8dd4eb5cac
400473,Cephas,Joseph,9205,Regular,0500-1330,U30 TRK,TM202,Off,,,Off,,,0500-1330,U30 TRK,TM202,0500-1330,U30 TRK,TM202,0500-1330,U30 TRK,TM202,0500-1330,U30 TRK,TM202,81dbf578-1e55-4877-979a-5e6faa123bb1
921081,Jarquin,Justin,9240,Regular,1300-2130,U30 TRK,TM217,1300-2130,U30 TRK,TM217,1300-2130,U30 TRK,TM217,Off,,,Off,,,1300-2130,U30 TRK,TM217,1300-2130,U30 TRK,TM217,ecb7695d-a567-4db7-9338-8fde6fd8d9b2
921047,Degale,Justin,9255,Regular,Off,,,Off,,,1400-2230,U30 TRK,TM221,1400-2230,U30 TRK,TM221,1400-2230,U30 TRK,TM221,1400-2230,U30 TRK,TM221,1400-2230,U30 TRK,TM221,e32dfcc6-d704-4dec-85f0-d86b8e17488b
331206,Mitchell,Kendra,9226,Regular,0700-1530,U30 TRK,TM207,0700-1530,U30 TRK,TM208,0700-1530,U30 TRK,TM208,0700-1530,U30 CAT,FSA,Off,,,Off,,,0700-1530,U30 TRK,TM207,2ecadad1-6489-4ac9-8d90-b2cd61f41975
921067,Behlin,Kenneth,9238,Regular,1300-2130,U30 TRK,TM216,Off,,,Off,,,1300-2130,U30 TRK,TM216,1300-2130,U30 TRK,TM216,1300-2130,U30 TRK,TM216,1300-2130,U30 TRK,TM216,3d73389e-f062-4cd4-9b75-c42a32ffa0b3
73717,Murray,Kevonna,9218,Regular,0700-1530,U30 TRK,TM208,Off,,,Off,,,0700-1530,U30 TRK,TM208,0700-1530,U30 TRK,TM208,0700-1530,U30 TRK,TM208,0700-1530,U30 TRK,TM208,7dddb9ae-2546-4ed0-8d8a-e80114b206af
854651,Boyd,Lamar,9245,Regular,1300-2130,U30 TRK,TM220,1300-2130,U30 TRK,TM220,1300-2130,U30 TRK,TM220,Off,,,Off,,,1300-2130,U30 TRK,TM220,1300-2130,U30 TRK,TM220,907cca70-6458-4617-9890-d8724c7215a6
404687,Ryons,Lawrence,9222,Variable,0600-1430,U30 TRK,TM205,0600-1430,U30 TRK,TM205,0500-1330,U30 TRK,TM202,0500-1330,U30 TRK,TM203,0500-1330,U30 TRK,TM203,Off,,,Off,,,8b440088-b3c8-4528-af33-fcff47c72df1
377077,Johnson,Levern,9241,Regular,1300-2130,U30 TRK,TM218,1300-2130,U30 TRK,TM218,1300-2130,U30 TRK,TM218,1300-2130,U30 TRK,TM218,1300-2130,U30 TRK,TM218,Off,,,Off,,,53192c23-99c1-43ca-b66c-912f20ffbc18
129413,Cherry,Luther,9224,Variable,Off,,,Off,,,0600-1430,U30 CAT,FSA,0600-1430,U30 TRK,TM206,0600-1430,U30 TRK,TM206,0500-1330,U30 TRK,TM204,0500-1330,U30 TRK,TM204,48df5eef-af16-4d1b-8755-1cd8ef3deeca
921082,Maddox,Makai,9247,Regular,1300-2130,U30 TRK,TM219,1300-2130,U30 TRK,TM219,Off,,,Off,,,1300-2130,U30 TRK,TM217,1300-2130,U30 TRK,TM218,1300-2130,U30 TRK,TM218,84db4785-1849-487d-a255-70d8bec2d30c
290046,White,Marnise,9236,Regular,Off,,,1300-2130,U30 TRK,TM215,1300-2130,U30 TRK,TM215,1300-2130,U30 TRK,TM215,1300-2130,U30 TRK,TM215,1300-2130,U30 TRK,TM215,Off,,,f8d296d0-a853-42fa-a304-edeaf87df861
902780,Powell,Matthew,9237,Regular,1300-2130,U30 TRK,TM216,Off,,,Off,,,1300-2130,U30 TRK,TM216,1300-2130,U30 TRK,TM216,1300-2130,U30 TRK,TM216,1300-2130,U30 TRK,TM216,7e1cef6c-908c-4996-9532-bcf1ee1e6cef
192876,Grace,Michael,9209,Regular,0500-1330,U30 TRK,TM204,0500-1330,U30 TRK,TM204,0500-1330,U30 TRK,TM204,0500-1330,U30 TRK,TM204,0500-1330,U30 TRK,TM204,Off,,,Off,,,11c511ed-78b5-481d-b2f3-23b5eb3b22c1
372320,Regan,Michael,9212,Regular,Off,,,Off,,,0600-1430,U30 TRK,TM205,0600-1430,U30 TRK,TM205,0600-1430,U30 TRK,TM205,0600-1430,U30 TRK,TM205,0600-1430,U30 TRK,TM205,3105f705-ec09-437c-b8bb-3bb43d92d7c5
921086,Ropski,Michael,9260,Regular,1400-2230,U30 TRK,TM222,1400-2230,U30 TRK,TM222,1400-2230,U30 TRK,TM222,Off,,,Off,,,1400-2230,U30 TRK,TM223,1400-2230,U30 TRK,TM223,f8b1add6-eba5-4e8d-86c4-576b25f5077a
921070,Morris,Natasha,9243,Regular,Off,,,Off,,,1300-2130,U30 TRK,TM219,1300-2130,U30 TRK,TM219,1300-2130,U30 TRK,TM219,1300-2130,U30 TRK,TM219,1300-2130,U30 TRK,TM219,5b311361-4cff-4be6-9bdc-7112c83c6422
351691,Lewis,Nathaniel,9214,Regular,0600-1430,U30 TRK,TM206,0600-1430,U30 TRK,TM206,0600-1430,U30 TRK,TM206,Off,,,Off,,,0600-1430,U30 TRK,TM206,0600-1430,U30 TRK,TM206,48cb99a3-8b31-4fc5-a444-bb26de75ec04
190212,Henderson,Patrick,9215,Regular,Off,,,0700-1530,U30 TRK,TM207,0700-1530,U30 TRK,TM207,0700-1530,U30 TRK,TM207,0700-1530,U30 TRK,TM207,0700-1530,U30 TRK,TM207,Off,,,553eade8-1438-4889-af5c-5d1a0b6fc216
405592,Odrick,Quentin,9208,Regular,0500-1330,U30 TRK,TM203,0500-1330,U30 TRK,TM203,0500-1330,U30 TRK,TM203,Off,,,Off,,,0500-1330,U30 TRK,TM203,0500-1330,U30 TRK,TM203,ac03a0a1-9e6f-4e1e-8d50-ff2ddf67e1b9
101916,Smith,Rashaan,9201,Regular,Off,,,0300-1130,U30 TRK,TM200,0300-1130,U30 TRK,TM200,0300-1130,U30 TRK,TM200,0300-1130,U30 TRK,TM200,0300-1130,U30 TRK,TM200,Off,,,41aa2ee2-e0c3-4c37-a1c2-dc43e9a7a005
921072,Negron,Raul,9262,Regular,Off,,,Off,,,1400-2230,U30 TRK,TM223,1400-2230,U30 TRK,TM223,1400-2230,U30 TRK,TM223,1400-2230,U30 TRK,TM223,1400-2230,U30 TRK,TM223,d59ce3bf-474e-4898-b053-451fb3b97da1
193409,Burrell,Samiro,9203,Regular,0400-1230,U30 TRK,TM201,0400-1230,U30 TRK,TM201,0400-1230,U30 TRK,TM201,0400-1230,U30 TRK,TM201,Off,,,Off,,,0400-1230,U30 TRK,TM201,0d2f5e64-a02d-4582-87ba-4a65920006b1
921059,Tucker,Semaj,9248,Regular,1300-2130,U30 TRK,TM219,1300-2130,U30 TRK,TM219,Off,,,Off,,,1300-2130,U30 TRK,TM217,1300-2130,U30 TRK,TM218,1300-2130,U30 TRK,TM218,1dda92d3-26a3-47e2-a078-a42eb286b90e
921085,Sem,Sokhar,9257,Regular,1400-2230,U30 TRK,TM221,1400-2230,U30 TRK,TM221,1400-2230,U30 TRK,TM221,1400-2230,U30 TRK,TM221,Off,,,Off,,,1400-2230,U30 TRK,TM222,39c15eeb-adfb-463e-b7fc-9a68993a0783
712289,George,Sunny,9202,Regular,Off,,,0300-1130,U30 TRK,TM200,0300-1130,U30 TRK,TM200,0300-1130,U30 TRK,TM200,0300-1130,U30 TRK,TM200,0300-1130,U30 TRK,TM200,Off,,,f7c56c2e-e032-4183-8bb2-053a67a822a3
921074,Eberhardt,Tameer,9234,Regular,1300-2130,U30 TRK,TM214,1300-2130,U30 TRK,TM214,1300-2130,U30 TRK,TM214,1300-2130,U30 TRK,TM214,Off,,,Off,,,1300-2130,U30 TRK,TM214,c851208c-6cc5-4672-8c7d-3f3673fe8d59
497739,Jones,Timothy,9227,Regular,Off,,,1200-2030,U30 TRK,TM210,1200-2030,U30 TRK,TM210,1200-2030,U30 TRK,TM210,1200-2030,U30 TRK,TM210,1200-2030,U30 TRK,TM210,Off,,,8f0bbf3b-1db5-4d5d-839e-db201313dfb8
956540,Newman,Tykeir,9256,Regular,1400-2230,U30 TRK,TM221,1400-2230,U30 TRK,TM221,Off,,,Off,,,1400-2230,U30 TRK,TM221,1400-2230,U30 TRK,TM221,1400-2230,U30 TRK,TM221,ed3878d9-774d-4d79-ac53-9fc499ddf21a
921053,Nelson,Unique,9239,Regular,1300-2130,U30 TRK,TM217,1300-2130,U30 TRK,TM217,1300-2130,U30 TRK,TM217,Off,,,Off,,,1300-2130,U30 TRK,TM217,1300-2130,U30 TRK,TM217,0b48dcba-4625-4d93-9134-da8beebab9bf
786398,Antwi,Victor,9258,Regular,Off,,,1400-2230,U30 TRK,TM222,1400-2230,U30 TRK,TM222,1400-2230,U30 TRK,TM222,1400-2230,U30 TRK,TM222,1400-2230,U30 TRK,TM222,Off,,,63888de4-65b0-438d-b3db-b0beb580de92
777030,Doloson,Wellington,9223,Variable,0600-1430,U30 CAT,FSA,Off,,,Off,,,0600-1430,U30 TRK,TM206,0600-1430,U30 TRK,TM206,0500-1330,U30 TRK,TM204,0500-1330,U30 TRK,TM204,ab1b1a6b-dbb6-402e-88a6-21f1f9b3863b`;

        const PT_AGENTS_CSV = `AA ID,Last Name,First Name,LN #,LineType,Monday,Mon Department,Mon Team,Tuesday,Tues Department,Tues Team,Wednesday,Wed Department,Wed Team,Thursday,Thurs Department,Thurs Team,Friday,Fri Department,Fri Team,Saturday,Sat Department,Sat Team,Sunday,Sun Department,Sun Team,__PowerAppsId__
804352,Byrd,Juwan,9501,Regular,Off,,,Off,,,0500-1100,U00 TRK,TM100,0500-1100,U00 TRK,TM100,0500-1100,U00 TRK,TM100,0500-1100,U00 TRK,TM100,0500-1100,U00 TRK,TM100,b0fec253-3e78-4ebf-bc9f-25458ab0af44
384846,Hardnett,Charlene,9502,Regular,0500-1100,U00 TRK,TM100,0500-1100,U00 TRK,TM100,Off,,,Off,,,0500-1100,U00 TRK,TM100,0500-1100,U00 TRK,TM100,0500-1100,U00 TRK,TM100,20eed17c-a43f-4f54-a4dd-ebf55ecdaff5
569593,Stevens,Michael,9503,Regular,0500-1100,U00 TRK,TM100,0500-1100,U00 TRK,TM100,0500-1100,U00 TRK,TM100,0500-1100,U00 TRK,TM100,Off,,,Off,,,0500-1100,U00 TRK,TM101,41da075c-e422-4059-beb7-1e2a3083314c
216865,Whitfield,Jasmine,9504,Regular,Off,,,0500-1100,U00 TRK,TM101,0500-1100,U00 TRK,TM101,0500-1100,U00 TRK,TM101,0500-1100,U00 TRK,TM101,0500-1100,U00 TRK,TM101,Off,,,cb64762b-9150-47ae-acd0-9d73f516f633
803931,Williams,Tenille,9505,Regular,0500-1100,U00 TRK,TM101,Off,,,Off,,,0500-1100,U00 TRK,TM101,0500-1100,U00 TRK,TM101,0500-1100,U00 TRK,TM101,0500-1100,U00 TRK,TM101,52c0c52d-9c0e-4c84-bc49-2a0be476ee49
296353,Marchetti-Mercer,Samantha,9506,Regular,0500-1100,U00 TRK,TM101,0500-1100,U00 TRK,TM101,0500-1100,U00 TRK,TM101,Off,,,Off,,,0500-1100,U00 CAT,FSA,0500-1100,U00 CAT,FSA,434d2a9c-866b-4c23-9c9d-0f6bb72ed8f4
646638,Ellison,Christopher,9507,Regular,Off,,,Off,,,0800-1400,U00 TRK,TM102,0800-1400,U00 TRK,TM102,0800-1400,U00 TRK,TM102,0800-1400,U00 TRK,TM102,0800-1400,U00 TRK,TM102,e413c651-a1a7-43bb-ae07-8090fe6a503f
282697,Johnson,Stephen,9508,Regular,0800-1400,U00 TRK,TM102,0800-1400,U00 TRK,TM102,Off,,,Off,,,0800-1400,U00 TRK,TM102,0800-1400,U00 TRK,TM102,0800-1400,U00 TRK,TM102,3198fed5-9605-420a-974d-d5527f321400
241546,Atkinson,Adrian,9509,Regular,0800-1400,U00 TRK,TM102,0800-1400,U00 TRK,TM102,0800-1400,U00 TRK,TM102,0800-1400,U00 TRK,TM102,Off,,,Off,,,0800-1400,U00 TRK,TM103,0058857b-b4f7-413d-8d8f-d0fcf4cb4c8a
562349,Gomez,Kimberly,9510,Regular,Off,,,0800-1400,U00 TRK,TM103,0800-1400,U00 TRK,TM103,0800-1400,U00 TRK,TM103,0800-1400,U00 TRK,TM103,0800-1400,U00 TRK,TM103,Off,,,6ec44e7d-80b9-4841-beda-556661e66afe
952387,McIntosh,Abegale,9511,Regular,0800-1400,U00 TRK,TM103,Off,,,Off,,,0800-1400,U00 TRK,TM103,0800-1400,U00 TRK,TM103,0800-1400,U00 TRK,TM103,0800-1400,U00 TRK,TM103,fc46e45e-0fff-4813-b424-17f0cf1c054f
296945,Howard,Katrina,9512,Regular,0800-1400,U00 TRK,TM103,0800-1400,U00 TRK,TM103,0800-1400,U00 TRK,TM103,Off,,,Off,,,0800-1400,U00 CAT,FSA,0800-1400,U00 CAT,FSA,6774ea08-5418-4d13-9d24-69a9062f0fdc
297908,Williams,Asia,9513,Regular,Off,,,1400-2000,U00 TRK,TM104,1400-2000,U00 TRK,TM104,1400-2000,U00 TRK,TM104,1400-2000,U00 TRK,TM104,1400-2000,U00 TRK,TM104,Off,,,e3d52d9d-b9d7-423c-a71d-ee49c9128c77
271553,Gilliard,Curtis,9514,Regular,1400-2000,U00 TRK,TM104,Off,,,Off,,,1400-2000,U00 TRK,TM104,1400-2000,U00 TRK,TM104,1400-2000,U00 TRK,TM104,1400-2000,U00 TRK,TM104,509b1002-21c2-47b6-9b25-424cc61fea98
956545,Porter,Brandon,9515,Regular,1400-2000,U00 TRK,TM104,1400-2000,U00 TRK,TM104,1400-2000,U00 TRK,TM104,Off,,,Off,,,1400-2000,U00 TRK,TM105,1400-2000,U00 TRK,TM104,760523ed-7b04-45d2-8ab4-82872bb4ba5d
956560,Chambers,Richard,9516,Regular,1400-2000,U00 TRK,TM105,1400-2000,U00 TRK,TM105,1400-2000,U00 TRK,TM105,1400-2000,U00 TRK,TM105,1400-2000,U00 TRK,TM105,Off,,,Off,,,dabd5fc4-81c1-42c1-a233-b88b5faac086
956551,Bost,Lahmar,9517,Regular,Off,,,Off,,,1400-2000,U00 TRK,TM105,1400-2000,U00 TRK,TM105,1400-2000,U00 TRK,TM105,1400-2000,U00 TRK,TM105,1400-2000,U00 TRK,TM105,5e8a2339-aef6-4ab1-9fd5-195fcba454a4
955304,Wells,Reginald,9518,Regular,1400-2000,U00 TRK,TM105,1400-2000,U00 TRK,TM105,Off,,,Off,,,1400-2000,U00 CAT,FSA,1400-2000,U00 CAT,FSA,1400-2000,U00 TRK,TM105,068df0ab-e8a3-4b72-97cf-a2e7a624e6ec
956559,Chamaq,Soulaimane,9520,Regular,1500-2100,U30 TRK,TM106,1500-2100,U30 TRK,TM106,Off,,,Off,,,1500-2100,U30 TRK,TM106,1500-2100,U30 TRK,TM106,1500-2100,U30 TRK,TM106,68ef0c7f-be2c-44f9-99ba-2758f13526ea
595289,Hayes,Amanda,9521,Regular,1500-2100,U30 TRK,TM106,1500-2100,U30 TRK,TM106,1500-2100,U30 TRK,TM106,1500-2100,U30 TRK,TM106,Off,,,Off,,,1500-2100,U30 TRK,TM107,f5c74cc2-15e9-4a7a-bfac-cf3413136cdd
956543,Wagenblast,Alanna,9522,Regular,Off,,,1500-2100,U30 TRK,TM107,1500-2100,U30 TRK,TM107,1500-2100,U30 TRK,TM107,1500-2100,U30 TRK,TM107,1500-2100,U30 TRK,TM107,Off,,,648a9048-b299-4d67-a91c-ac44fbd12637
952396,Ross,Kenesha,9524,Regular,1500-2100,U30 TRK,TM107,1500-2100,U30 TRK,TM107,1500-2100,U30 TRK,TM107,Off,,,Off,,,1500-2100,U30 CAT,FSA,1500-2100,U30 CAT,FSA,baed2bab-8e1d-419c-b121-5b1dd6ed4336
955300,Morris,Naya,9525,Regular,1500-2100,U30 TRK,TM108,Off,,,Off,,,1500-2100,U30 TRK,TM108,1500-2100,U30 TRK,TM108,1500-2100,U30 TRK,TM108,1500-2100,U30 TRK,TM108,a195fd32-51cd-44c2-9d27-3f62c59d51ed
899217,Simms,Ellis,9526,Regular,1500-2100,U30 TRK,TM108,1500-2100,U30 TRK,TM108,1500-2100,U30 TRK,TM108,Off,,,Off,,,1500-2100,U30 TRK,TM108,1500-2100,U30 TRK,TM108,12234f6d-b8f8-4a73-8ae1-ea4f584915cf
956548,Debose,Zakhi,9527,Regular,Off,,,1500-2100,U30 TRK,TM108,1500-2100,U30 TRK,TM108,1500-2100,U30 TRK,TM108,1500-2100,U30 TRK,TM108,1500-2100,U30 CAT,FSA,Off,,,bf2a6941-6ca2-4179-8f35-9965af4fadab
474390,Lewis,Tamika,9528,Regular,Off,,,2300-0500,U00 TRK,TM110,2300-0500,U00 TRK,TM110,2300-0500,U00 TRK,TM110,2300-0500,U00 TRK,TM110,2300-0500,U00 TRK,TM110,Off,,,77568e95-a925-4deb-9759-1a7e7d26c513
466100,Powell,Joseph,9529,Regular,Off,,,2300-0500,U00 TRK,TM110,2300-0500,U00 TRK,TM110,2300-0500,U00 TRK,TM110,2300-0500,U00 TRK,TM110,2300-0500,U00 TRK,TM110,Off,,,f22382f7-7fb0-47e5-8b17-328559175231
563820,Boyle,Hugh,9530,Regular,2300-0500,U00 TRK,TM111,2300-0500,U00 TRK,TM111,2300-0500,U00 TRK,TM111,2300-0500,U00 TRK,TM111,Off,,,Off,,,2300-0500,U00 TRK,TM111,7f5b8bce-26c6-4da3-bae0-72394076eb7c
464032,Mcbride,Joseph,9531,Regular,2300-0500,U00 TRK,TM111,2300-0500,U00 TRK,TM111,2300-0500,U00 TRK,TM111,2300-0500,U00 TRK,TM111,Off,,,Off,,,2300-0500,U00 TRK,TM111,e68d3790-bbd6-4be0-a486-252a2dfcd7d8
955502,Jackson,Kevin,9532,Regular,2300-0500,U00 TRK,TM110,2300-0500,U00 CAT,FSA,Off,,,Off,,,2300-0500,U00 TRK,TM111,2300-0500,U00 TRK,TM111,2300-0500,U00 TRK,TM110,d16b45bb-b682-44f2-a413-db037e1d8608
539638,Valcarcel,Angel,9533,Regular,2300-0500,U00 TRK,TM110,Off,,,Off,,,2300-0500,U00 CAT,FSA,2300-0500,U00 TRK,TM111,2300-0500,U00 TRK,TM111,2300-0500,U00 TRK,TM111,8c432993-13a5-4563-b552-cdd13bbe1a0e`;

        // Global data storage
        let ftAgentsData = null;
        let ptAgentsData = null;
        let flightsData = null;
        let scheduleResult = null;

        // Auto-load agent data on page load
        window.addEventListener('DOMContentLoaded', () => {
            ftAgentsData = parseCSV(FT_AGENTS_CSV);
            ptAgentsData = parseCSV(PT_AGENTS_CSV);
            console.log(`‚úì Pre-loaded ${ftAgentsData.length} full-time agents`);
            console.log(`‚úì Pre-loaded ${ptAgentsData.length} part-time agents`);
        });

        // File upload handler (only for flights now)
        document.getElementById('flights').addEventListener('change', (e) => handleFileUpload(e, 'flights'));

        function handleFileUpload(event, type) {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = (e) => {
                const text = e.target.result;
                const data = parseCSV(text);
                
                flightsData = data;
                document.getElementById('flightStatus').textContent = `‚úì Loaded ${data.length} flights`;
                checkReadyToGenerate();
            };
            reader.readAsText(file);
        }

        function parseCSV(text) {
            const lines = text.trim().split('\n');
            const headers = lines[0].split(',').map(h => h.trim());
            const data = [];

            for (let i = 1; i < lines.length; i++) {
                const values = lines[i].split(',');
                const row = {};
                headers.forEach((header, index) => {
                    row[header] = values[index] ? values[index].trim() : '';
                });
                data.push(row);
            }

            return data;
        }

        function checkReadyToGenerate() {
            // Agent data is pre-loaded, only need flights
            const ready = ftAgentsData && ptAgentsData && flightsData;
            document.getElementById('generateBtn').disabled = !ready;
        }

        // Schedule generation
        document.getElementById('generateBtn').addEventListener('click', generateSchedule);

        function generateSchedule() {
            document.getElementById('loading').classList.add('active');
            document.getElementById('results').style.display = 'none';

            // Simulate processing time for better UX
            setTimeout(() => {
                try {
                    scheduleResult = createSchedule();
                    displayResults(scheduleResult);
                    document.getElementById('loading').classList.remove('active');
                    document.getElementById('results').style.display = 'block';
                    document.getElementById('exportBtn').disabled = false;
                } catch (error) {
                    alert('Error generating schedule: ' + error.message);
                    document.getElementById('loading').classList.remove('active');
                }
            }, 1000);
        }

        function createSchedule() {
            console.log('=== Starting Schedule Generation ===');
            
            // Get selected day of week
            const dayOfWeek = document.getElementById('dayOfWeek').value;
            console.log(`Scheduling for: ${dayOfWeek}`);
            
            const teams = extractTeams(ftAgentsData, ptAgentsData, dayOfWeek);
            console.log(`Teams extracted: ${teams.length}`);
            
            if (teams.length === 0) {
                throw new Error(`No teams found for ${dayOfWeek}. Check that your agent CSV files have ${dayOfWeek} data.`);
            }
            
            // Log team shift distribution
            const shiftDistribution = {};
            teams.forEach(team => {
                const hour = Math.floor(team.startMinutes / 60);
                shiftDistribution[hour] = (shiftDistribution[hour] || 0) + 1;
            });
            console.log('Team shift distribution:', shiftDistribution);
            
            const flightData = processFlights(flightsData);
            const flights = flightData.departures;
            const terminators = flightData.terminators;
            
            console.log(`‚úàÔ∏è DEPARTURES to assign: ${flights.length}`);
            console.log(`üî∂ TERMINATORS (skipped for now): ${terminators.length}`);
            console.log(`üìã FOCUS: 100% coverage of DEPARTING flights\n`);
            
            if (flights.length === 0) {
                throw new Error('No valid departure flights found. Check that your flight CSV has departure times.');
            }

            // Analyze flight timing distribution (departures only)
            const flightsByType = {
                Overnight: flights.filter(f => f.operationType === 'Overnight').length,
                ShortTurn: flights.filter(f => f.operationType === 'ShortTurn').length,
                LongTurn: flights.filter(f => f.operationType === 'LongTurn').length
            };
            console.log('Departure flight types:', flightsByType);

            // Phase-based assignment
            const assignments = [];
            const unassigned = [];
            const teamWorkload = {};

            // OPTIMIZATION: Use Set for O(1) lookup instead of O(n) .some() on assignments array
            const assignedFlights = new Set();

            teams.forEach(team => {
                teamWorkload[team.id] = {
                    team: team,
                    operations: [],
                    count: 0,
                    truckLoad: [] // Track current truck load (max 3 domestic or 1 intl)
                };
            });

            console.log('Starting phase-based assignment...');

            // **PHASE 1: Early Short Turns (STD < 07:00) - HIGHEST PRIORITY**
            const earlyShortTurns = flights.filter(f =>
                f.operationType === 'ShortTurn' &&
                f.timeMinutes < 420 &&
                !assignedFlights.has(f)
            );
            console.log(`Phase 1 - Early Short Turns: ${earlyShortTurns.length} flights`);
            assignFlightsFlexible(earlyShortTurns, teams, assignments, unassigned, teamWorkload, assignedFlights, 'early_short_turns');

            // **PHASE 1B: PRIORITY INTERNATIONAL - Assign ALL international flights FIRST**
            const allInternational = flights.filter(f =>
                (f.type === 'International' || f.type === 'Precleared') &&
                !assignedFlights.has(f)
            );
            
            if (allInternational.length > 0) {
                console.log(`\nüåç PHASE 1B - PRIORITY INTERNATIONAL: ${allInternational.length} flights (MUST COVER)`);
                
                const sortedIntl = [...allInternational].sort((a, b) => a.timeMinutes - b.timeMinutes);
                
                sortedIntl.forEach(flight => {
                    let bestTeam = null;
                    let bestScore = -Infinity;
                    
                    teams.forEach(team => {
                        const workload = teamWorkload[team.id];
                        
                        const shiftStart = team.startMinutes - 30;
                        const shiftEnd = team.startMinutes + (8.5 * 60);
                        const finishTime = flight.timeMinutes + 60 + 30;
                        
                        if (flight.timeMinutes < shiftStart || finishTime > shiftEnd) return;
                        
                        const maxOps = team.type === 'PT' ? 4 : 8;
                        if (workload.count >= maxOps) return;
                        
                        let score = 0;
                        
                        if (workload.count === 0) {
                            score = 1000;
                        } else {
                            const allExistingIntl = workload.operations.every(op => 
                                op.type === 'International' || op.type === 'Precleared'
                            );
                            
                            if (allExistingIntl) {
                                let fits = true;
                                for (let op of workload.operations) {
                                    if (Math.abs(flight.timeMinutes - op.timeMinutes) < 120) {
                                        fits = false;
                                        break;
                                    }
                                }
                                if (fits) score = 800 - (workload.count * 100);
                            } else {
                                let fits = true;
                                for (let op of workload.operations) {
                                    const requiredBuffer = (op.type === 'Domestic') ? 90 : 120;
                                    if (Math.abs(flight.timeMinutes - op.timeMinutes) < requiredBuffer) {
                                        fits = false;
                                        break;
                                    }
                                }
                                if (fits) score = 400 - (workload.count * 50);
                            }
                        }
                        
                        if (score > bestScore) {
                            bestScore = score;
                            bestTeam = team;
                        }
                    });
                    
                    if (bestTeam) {
                        const workload = teamWorkload[bestTeam.id];
                        assignments.push({
                            flight: flight,
                            team: bestTeam.id,
                            phase: 'priority_international'
                        });
                        assignedFlights.add(flight); // OPTIMIZATION: Track in Set for O(1) lookup
                        workload.operations.push(flight);
                        // OPTIMIZATION: Don't sort here - will sort once at the end
                        workload.count++;
                        console.log(`‚úì PRIORITY INTL: ${flight.flight} (${flight.time}) ‚Üí ${bestTeam.id}`);
                    }
                });
            }

            // **PHASE 2: Early Overnight domestic (before 07:00)**
            const earlyOvernights = flights.filter(f =>
                f.operationType === 'Overnight' &&
                f.type === 'Domestic' &&
                f.timeMinutes < 420 &&
                !assignedFlights.has(f)
            );
            console.log(`Phase 2 - Early Overnights: ${earlyOvernights.length} flights`);
            assignFlightsFlexible(earlyOvernights, teams, assignments, unassigned, teamWorkload, assignedFlights, 'early_overnights');

            // **PHASE 3: Mid-day Short Turns (07:00-18:00)**
            const middayShortTurns = flights.filter(f =>
                f.operationType === 'ShortTurn' &&
                f.timeMinutes >= 420 && f.timeMinutes < 1080 &&
                !assignedFlights.has(f)
            );
            console.log(`Phase 3 - Midday Short Turns: ${middayShortTurns.length} flights`);
            assignFlightsFlexible(middayShortTurns, teams, assignments, unassigned, teamWorkload, assignedFlights, 'midday_short_turns');

            // **PHASE 4: Mid-day Overnight/Long Turn domestic (07:00-18:00)**
            const middayOther = flights.filter(f =>
                (f.operationType === 'Overnight' || f.operationType === 'LongTurn') &&
                f.type === 'Domestic' &&
                f.timeMinutes >= 420 && f.timeMinutes < 1080 &&
                !assignedFlights.has(f)
            );
            console.log(`Phase 4 - Midday Overnight/LongTurn: ${middayOther.length} flights`);
            assignFlightsFlexible(middayOther, teams, assignments, unassigned, teamWorkload, assignedFlights, 'midday_other');

            // **PHASE 6: Late Short Turns (after 18:00)**
            const lateShortTurns = flights.filter(f =>
                f.operationType === 'ShortTurn' &&
                f.timeMinutes >= 1080 &&
                !assignedFlights.has(f)
            );
            console.log(`Phase 6 - Late Short Turns: ${lateShortTurns.length} flights`);
            assignFlightsFlexible(lateShortTurns, teams, assignments, unassigned, teamWorkload, assignedFlights, 'late_short_turns');

            // **PHASE 7: Late Overnight/Long Turn (after 18:00)**
            const lateOther = flights.filter(f =>
                (f.operationType === 'Overnight' || f.operationType === 'LongTurn') &&
                f.timeMinutes >= 1080 &&
                !assignedFlights.has(f)
            );
            console.log(`Phase 7 - Late Overnight/LongTurn: ${lateOther.length} flights`);
            assignFlightsFlexible(lateOther, teams, assignments, unassigned, teamWorkload, assignedFlights, 'late_other');

            // **PHASE 9: Terminators (flexible timing - optimize for coverage)**
            // **PHASE 9: AGGRESSIVE GAP FILLING - Maximize team utilization**
            const underutilized = Object.values(teamWorkload).filter(tw => 
                (tw.count < 6 && tw.team.type === 'FT') || (tw.count < 4 && tw.team.type === 'PT')
            );
            
            if (underutilized.length > 0) {
                console.log(`\nüîç PHASE 9 - AGGRESSIVE GAP FILLING: ${underutilized.length} underutilized FT teams`);

                const unassignedForGapFill = flights.filter(f => !assignedFlights.has(f));
                
                // Process each unassigned flight
                unassignedForGapFill.forEach(flight => {
                    let bestTeam = null;
                    let bestScore = -1;
                    
                    underutilized.forEach(tw => {
                        // Allow teams to start 30 min before shift (early prep)
                        const shiftStart = tw.team.startMinutes - 30;
                        const shiftEnd = tw.team.startMinutes + (8.5 * 60);
                        const serviceTime = (flight.type === 'International' || flight.type === 'Precleared') ? 60 : 40;
                        const finishTime = flight.timeMinutes + serviceTime + 30;
                        
                        // Must be within extended shift window
                        if (flight.timeMinutes < shiftStart || finishTime > shiftEnd) return;
                        
                        let canAssign = false;
                        let score = 0;
                        
                        // CASE 1: Team has 0 operations - HIGHEST PRIORITY
                        if (tw.operations.length === 0) {
                            canAssign = true;
                            score = 1000; // Prioritize filling idle teams
                        }
                        // CASE 2: Team has 1-2 operations - check if flight fits with TYPE-AWARE buffers
                        else if (tw.operations.length <= 2) {
                            let fits = true;
                            
                            for (let existingOp of tw.operations) {
                                const timeDiff = flight.timeMinutes - existingOp.timeMinutes;
                                
                                // Calculate required buffer based on flight types
                                let requiredBuffer = 30; // Default domestic-domestic
                                
                                // Domestic ‚Üí International OR International ‚Üí Domestic
                                if ((existingOp.type === 'Domestic' && (flight.type === 'International' || flight.type === 'Precleared')) ||
                                    ((existingOp.type === 'International' || existingOp.type === 'Precleared') && flight.type === 'Domestic')) {
                                    requiredBuffer = 90; // Need reload time: service (40) + return (30) + load intl cart (20)
                                }
                                
                                // International ‚Üí International
                                if ((existingOp.type === 'International' || existingOp.type === 'Precleared') &&
                                    (flight.type === 'International' || flight.type === 'Precleared')) {
                                    requiredBuffer = 120; // Need: service (60) + return (30) + load intl cart (30)
                                }
                                
                                // Check both directions (before and after)
                                if (Math.abs(timeDiff) < requiredBuffer) {
                                    fits = false;
                                    break;
                                }
                            }
                            
                            if (fits) {
                                canAssign = true;
                                // Score based on how underutilized the team is
                                score = 500 - (tw.count * 100);
                            }
                        }
                        // CASE 3: Team has 3-5 operations - check gaps with TYPE-AWARE requirements
                        else {
                            // Check if flight fits between operations
                            let fits = true;
                            
                            for (let i = 0; i < tw.operations.length; i++) {
                                const existingOp = tw.operations[i];
                                const timeDiff = flight.timeMinutes - existingOp.timeMinutes;
                                
                                // Calculate required buffer based on flight types
                                let requiredBuffer = 30; // Default domestic-domestic
                                
                                // Domestic ‚Üí International OR International ‚Üí Domestic
                                if ((existingOp.type === 'Domestic' && (flight.type === 'International' || flight.type === 'Precleared')) ||
                                    ((existingOp.type === 'International' || existingOp.type === 'Precleared') && flight.type === 'Domestic')) {
                                    requiredBuffer = 90;
                                }
                                
                                // International ‚Üí International
                                if ((existingOp.type === 'International' || existingOp.type === 'Precleared') &&
                                    (flight.type === 'International' || flight.type === 'Precleared')) {
                                    requiredBuffer = 120;
                                }
                                
                                // Check both directions
                                if (Math.abs(timeDiff) < requiredBuffer) {
                                    fits = false;
                                    break;
                                }
                            }
                            
                            if (fits) {
                                canAssign = true;
                                // Lower score for teams that already have more operations
                                score = 300 - (tw.count * 50);
                            }
                        }
                        
                        if (canAssign && score > bestScore) {
                            bestScore = score;
                            bestTeam = tw;
                        }
                    });
                    
                    if (bestTeam) {
                        assignments.push({
                            flight: flight,
                            team: bestTeam.team.id,
                            phase: 'aggressive_gap_fill'
                        });
                        assignedFlights.add(flight); // OPTIMIZATION: Track in Set for O(1) lookup
                        // Add to operations (will sort all at once later)
                        bestTeam.operations.push(flight);
                        // OPTIMIZATION: Don't sort here - will sort once at the end
                        bestTeam.count++;
                        console.log(`‚úì AGG GAP FILL: ${flight.flight} (${flight.time}) ‚Üí ${bestTeam.team.id} (count now: ${bestTeam.count}, score: ${bestScore})`);
                    }
                });
            }
            
            // **PHASE 10: Final sweep - try to assign remaining departures with relaxed constraints**
            const stillUnassigned = flights.filter(f =>
                !assignedFlights.has(f)
            );
            if (stillUnassigned.length > 0) {
                console.log(`Phase 8 - Final Sweep: ${stillUnassigned.length} departures remaining`);
                assignFlightsVeryFlexible(stillUnassigned, teams, assignments, unassigned, teamWorkload, assignedFlights, 'final_sweep');
            }

            // TERMINATORS SKIPPED - Focus on 100% departure coverage first

            // **PHASE 11: AGGRESSIVE REBALANCING - Utilize idle teams**
            const currentlyIdle = Object.values(teamWorkload).filter(tw => tw.count === 0);
            const remainingUnassigned = flights.filter(f => !assignedFlights.has(f));
            
            if (currentlyIdle.length > 0 && remainingUnassigned.length > 0) {
                console.log(`\n‚ö†Ô∏è PHASE 11 - AGGRESSIVE REBALANCING: ${currentlyIdle.length} idle teams, ${remainingUnassigned.length} unassigned`);
                
                // Try VERY relaxed constraints for idle teams
                remainingUnassigned.forEach(flight => {
                    for (let tw of currentlyIdle) {
                        const team = tw.team;
                        
                        // Check if team can physically reach this flight (ignore most other constraints)
                        if (canTeamReachFlight(team, flight)) {
                            const shiftEnd = team.startMinutes + (8.5 * 60);
                            const serviceTime = (flight.type === 'International' || flight.type === 'Precleared') ? 60 : 40;
                            const finishTime = flight.timeMinutes + serviceTime + 30;
                            
                            // Only hard requirement: must finish before shift end
                            if (finishTime <= shiftEnd) {
                                assignments.push({
                                    flight: flight,
                                    team: team.id,
                                    phase: 'aggressive_rebalance'
                                });
                                assignedFlights.add(flight); // OPTIMIZATION: Track in Set for O(1) lookup
                                tw.operations.push(flight);
                                tw.count++;
                                console.log(`‚úì AGGRESSIVE: ${flight.flight} (${flight.time}) ‚Üí ${team.id} (was idle)`);
                                break; // Move to next flight
                            }
                        }
                    }
                });
            }
            
            // **PHASE 11: WORKLOAD BALANCING - Steal from overloaded teams for idle teams**
            const finallyIdle = Object.values(teamWorkload).filter(tw => tw.count === 0);
            if (finallyIdle.length > 0) {
                console.log(`\n‚ö†Ô∏è PHASE 12 - WORKLOAD STEALING: ${finallyIdle.length} idle teams remain`);

                // OPTIMIZATION: Create assignment Map for O(1) lookup instead of O(n) findIndex
                const assignmentMap = new Map();
                assignments.forEach((assignment, index) => {
                    // Create unique key from flight and team
                    const key = `${assignment.flight.flight}_${assignment.flight.timeMinutes}_${assignment.team}`;
                    assignmentMap.set(key, index);
                });

                // Find overloaded teams (more than 5 ops for FT, 4 for PT)
                const overloaded = Object.values(teamWorkload).filter(tw =>
                    tw.count > (tw.team.type === 'PT' ? 4 : 5)
                );

                overloaded.forEach(overloadedTW => {
                    // Try to move some of their operations to idle teams
                    for (let i = overloadedTW.operations.length - 1; i >= 0 && finallyIdle.length > 0; i--) {
                        const op = overloadedTW.operations[i];

                        // Try to assign this operation to an idle team
                        for (let idleTW of finallyIdle) {
                            if (canTeamReachFlight(idleTW.team, op)) {
                                const shiftEnd = idleTW.team.startMinutes + (8.5 * 60);
                                const serviceTime = (op.type === 'International' || op.type === 'Precleared') ? 60 : 40;
                                const finishTime = op.timeMinutes + serviceTime + 30;

                                if (finishTime <= shiftEnd) {
                                    // OPTIMIZATION: Use Map for O(1) lookup instead of findIndex O(n)
                                    const key = `${op.flight}_${op.timeMinutes}_${overloadedTW.team.id}`;
                                    const assignmentIndex = assignmentMap.get(key);
                                    
                                    if (assignmentIndex !== undefined) {
                                        // Update assignment
                                        const oldKey = key;
                                        const newKey = `${op.flight}_${op.timeMinutes}_${idleTW.team.id}`;

                                        assignments[assignmentIndex].team = idleTW.team.id;
                                        assignments[assignmentIndex].phase = 'workload_steal';

                                        // OPTIMIZATION: Update the Map index
                                        assignmentMap.delete(oldKey);
                                        assignmentMap.set(newKey, assignmentIndex);

                                        // Update workloads
                                        overloadedTW.operations.splice(i, 1);
                                        overloadedTW.count--;
                                        idleTW.operations.push(op);
                                        idleTW.count++;

                                        console.log(`‚úì STEAL: ${op.flight} moved from ${overloadedTW.team.id} (${overloadedTW.count+1}) to ${idleTW.team.id} (idle‚Üí1)`);

                                        // Remove from idle list if no longer idle
                                        const idleIndex = finallyIdle.indexOf(idleTW);
                                        if (idleIndex >= 0) finallyIdle.splice(idleIndex, 1);
                                        break;
                                    }
                                }
                            }
                        }
                    }
                });
            }

            // OPTIMIZATION: Sort all team operations once at the end instead of multiple times during assignment
            console.log('\nüîß Sorting all team operations by time...');
            Object.values(teamWorkload).forEach(tw => {
                if (tw.operations.length > 1) {
                    tw.operations.sort((a, b) => a.timeMinutes - b.timeMinutes);
                }
            });

            console.log(`\n=== FINAL SCHEDULE SUMMARY ===`);
            console.log(`Total Operations: ${flights.length + terminators.length}`);
            console.log(`Assigned: ${assignments.length}`);
            console.log(`Unassigned: ${unassigned.length}`);
            console.log(`Coverage: ${Math.round((assignments.length / (flights.length + terminators.length)) * 100)}%`);

            // Assignment breakdown by phase
            const phaseBreakdown = {};
            assignments.forEach(a => {
                phaseBreakdown[a.phase] = (phaseBreakdown[a.phase] || 0) + 1;
            });
            console.log('\nAssignments by phase:', phaseBreakdown);

            // DETAILED FAILURE ANALYSIS
            if (unassigned.length > 0) {
                console.log(`\n‚ùå === WHY WE FAILED TO REACH 100% (${unassigned.length} unassigned) ===`);
                
                // Group by flight type
                const unassignedByType = {};
                unassigned.forEach(u => {
                    const type = u.flight.type || 'Unknown';
                    if (!unassignedByType[type]) unassignedByType[type] = [];
                    unassignedByType[type].push(u);
                });
                
                Object.keys(unassignedByType).forEach(type => {
                    console.log(`\n${type} Flights (${unassignedByType[type].length}):`);
                    unassignedByType[type].forEach(u => {
                        console.log(`  ‚ùå ${u.flight.flight} (${u.flight.time}) - ${u.reason}`);
                    });
                });
                
                // Timing analysis
                const unassignedByHour = {};
                unassigned.forEach(u => {
                    const hour = Math.floor(u.flight.timeMinutes / 60);
                    if (!unassignedByHour[hour]) unassignedByHour[hour] = [];
                    unassignedByHour[hour].push(u.flight.flight);
                });
                console.log('\n‚è∞ Unassigned flights by hour:');
                Object.keys(unassignedByHour).sort((a,b) => a-b).forEach(h => {
                    console.log(`  ${h}:00 - ${unassignedByHour[h].length} flights: ${unassignedByHour[h].join(', ')}`);
                });
            }
            
            // Team utilization summary
            const utilizationBuckets = {
                '0 ops': 0,
                '1-2 ops': 0,
                '3-4 ops': 0,
                '5-6 ops': 0,
                '7+ ops': 0
            };
            Object.values(teamWorkload).forEach(tw => {
                if (tw.count === 0) utilizationBuckets['0 ops']++;
                else if (tw.count <= 2) utilizationBuckets['1-2 ops']++;
                else if (tw.count <= 4) utilizationBuckets['3-4 ops']++;
                else if (tw.count <= 6) utilizationBuckets['5-6 ops']++;
                else utilizationBuckets['7+ ops']++;
            });
            console.log('\nüìä Team utilization:', utilizationBuckets);

            // Check for idle teams
            const idleTeams = Object.values(teamWorkload).filter(tw => tw.count === 0);
            if (idleTeams.length > 0) {
                console.log(`\n‚ùå ${idleTeams.length} IDLE TEAMS:`);
                idleTeams.forEach(tw => {
                    const window = getTeamTimeWindow(tw.team);
                    console.log(`  ${tw.team.id} (${tw.team.shift}, ${tw.team.type}) - Window: ${window.startTime}-${window.endTime}`);
                });
            } else {
                console.log('\n‚úì All teams utilized!');
            }
            
            // Check for underutilized FT teams
            const underutilizedFT = Object.values(teamWorkload).filter(tw => 
                tw.team.type === 'FT' && tw.count > 0 && tw.count < 4
            );
            if (underutilizedFT.length > 0) {
                console.log(`\n‚ö†Ô∏è ${underutilizedFT.length} underutilized FT teams (<4 ops):`);
                underutilizedFT.forEach(tw => {
                    console.log(`  ${tw.team.id}: ${tw.count} ops`);
                });
            }

            // **PHASE 13: TERMINATOR STRIPS - BONUS capacity utilization**
            // Now that we have 100% departure coverage, try to assign terminators as BONUS work
            // Terminators NEVER displace departures - they only fill remaining capacity
            if (terminators.length > 0) {
                console.log(`\nüî∂ PHASE 13 - TERMINATOR STRIPS (BONUS): ${terminators.length} terminator arrivals`);
                console.log(`   Strategy: Assign terminators to teams with remaining capacity`);
                
                assignTerminators(terminators, teams, assignments, unassigned, teamWorkload, 'terminator_bonus');
                
                const terminatorAssignments = assignments.filter(a => a.operation === 'strip');
                console.log(`‚úì Terminator coverage: ${terminatorAssignments.length}/${terminators.length} (${Math.round((terminatorAssignments.length/terminators.length)*100)}%)`);
            }
            
            // **VALIDATION: Check for buffer violations**
            console.log('\nüîç VALIDATING BUFFER REQUIREMENTS...');
            const bufferViolations = [];

            Object.values(teamWorkload).forEach(tw => {
                if (tw.operations.length < 2) return;

                // OPTIMIZATION: Operations are already sorted above, no need to sort again
                const ops = tw.operations;
                
                for (let i = 1; i < ops.length; i++) {
                    const prevOp = ops[i-1];
                    const currOp = ops[i];
                    const actualBuffer = currOp.timeMinutes - prevOp.timeMinutes;
                    
                    // Determine required buffer
                    let requiredBuffer = 30; // Dom‚ÜíDom
                    let bufferType = 'Dom‚ÜíDom';
                    
                    if ((prevOp.type === 'Domestic' && (currOp.type === 'International' || currOp.type === 'Precleared')) ||
                        ((prevOp.type === 'International' || prevOp.type === 'Precleared') && currOp.type === 'Domestic')) {
                        requiredBuffer = 90;
                        bufferType = 'Dom‚ÜîIntl';
                    }
                    
                    if ((prevOp.type === 'International' || prevOp.type === 'Precleared') &&
                        (currOp.type === 'International' || currOp.type === 'Precleared')) {
                        requiredBuffer = 120;
                        bufferType = 'Intl‚ÜíIntl';
                    }
                    
                    if (actualBuffer < requiredBuffer) {
                        bufferViolations.push({
                            team: tw.team.id,
                            flight1: prevOp.flight,
                            time1: prevOp.time,
                            type1: prevOp.type,
                            flight2: currOp.flight,
                            time2: currOp.time,
                            type2: currOp.type,
                            actualBuffer: actualBuffer,
                            requiredBuffer: requiredBuffer,
                            bufferType: bufferType,
                            shortage: requiredBuffer - actualBuffer
                        });
                    }
                }
            });
            
            if (bufferViolations.length > 0) {
                console.log(`‚ö†Ô∏è BUFFER VIOLATIONS DETECTED: ${bufferViolations.length}`);
                bufferViolations.forEach(v => {
                    console.log(`  ${v.team}: ${v.flight1} (${v.time1}) ‚Üí ${v.flight2} (${v.time2}) | ${v.bufferType} needs ${v.requiredBuffer}min, only ${v.actualBuffer}min (SHORT ${v.shortage}min)`);
                });
            } else {
                console.log('‚úì All buffer requirements satisfied!');
            }

            // Analyze coverage gaps
            const unassignedByTime = {};
            unassigned.forEach(u => {
                const hour = Math.floor(u.flight.timeMinutes / 60);
                if (!unassignedByTime[hour]) unassignedByTime[hour] = [];
                unassignedByTime[hour].push(u.flight.flight);
            });
            if (Object.keys(unassignedByTime).length > 0) {
                console.log('Coverage gaps by hour:', unassignedByTime);
            }

            return {
                assignments,
                unassigned,
                teamWorkload: Object.values(teamWorkload),
                stats: calculateStats(assignments, unassigned, flights, terminators, teams),
                dayOfWeek: dayOfWeek,
                coverageGaps: unassignedByTime,
                idleTeams: idleTeams.map(tw => tw.team.id),
                bufferViolations: bufferViolations
            };
        }
        
        function assignTerminators(terminators, teams, assignments, unassigned, teamWorkload, phase) {
            console.log(`\n--- Assigning ${terminators.length} terminator strips ---`);

            // OPTIMIZATION: Terminators are already sorted by processFlights, but we keep this for safety
            // This sort is minimal cost since we create a copy anyway
            const sortedTerminators = [...terminators].sort((a, b) => a.timeMinutes - b.timeMinutes);
            
            sortedTerminators.forEach((terminator, index) => {
                let assigned = false;
                let bestTeam = null;
                let bestScore = -Infinity;

                // Find best team for this terminator
                // Prefer teams that are returning to unit (completed operations)
                for (let team of teams) {
                    const workload = teamWorkload[team.id];
                    
                    if (canAssignTerminator(team, terminator, workload)) {
                        // Score based on:
                        // 1. Teams with operations already (returning to unit)
                        // 2. Timing compatibility
                        // 3. Workload balance
                        let score = 0;
                        
                        if (workload.operations.length > 0) score += 100; // Prefer teams already working
                        
                        const lastOp = workload.operations[workload.operations.length - 1];
                        if (lastOp && lastOp.timeMinutes < terminator.timeMinutes) {
                            // Team can strip terminator after completing last operation
                            const timeDiff = terminator.timeMinutes - lastOp.timeMinutes;
                            score += Math.max(0, 50 - timeDiff / 10); // Closer is better
                        }
                        
                        score -= workload.count * 20; // Prefer less loaded teams
                        
                        if (score > bestScore) {
                            bestScore = score;
                            bestTeam = team;
                        }
                    }
                }

                if (bestTeam) {
                    const workload = teamWorkload[bestTeam.id];
                    assignments.push({
                        flight: terminator,
                        team: bestTeam.id,
                        phase: phase,
                        operation: 'strip'
                    });
                    workload.operations.push(terminator);
                    workload.count += 1; // Terminator strip = 1.0 operation
                    assigned = true;
                    
                    if (index < 5) {
                        console.log(`‚úì Terminator ${terminator.flight} (STA ${terminator.time}) ‚Üí ${bestTeam.id} strip`);
                    }
                } else {
                    unassigned.push({
                        flight: terminator,
                        reason: 'No team available for terminator strip within shift constraints'
                    });
                    
                    if (index < 5) {
                        console.log(`‚úó Terminator ${terminator.flight} (STA ${terminator.time}) - unassigned`);
                    }
                }
            });
            
            const terminatorAssignments = assignments.filter(a => a.operation === 'strip' && a.flight.operationType === 'Terminator');
            console.log(`Terminators assigned: ${terminatorAssignments.length}/${terminators.length}`);
        }
        
        function canAssignTerminator(team, terminator, workload) {
            // Team must have started shift
            const teamReadyTime = team.startMinutes + 45; // Flexible prep time
            
            // Terminator can be stripped anytime from arrival through end of shift
            // Must complete: strip (15 min) + return (30 min) before shift end
            const shiftEnd = team.startMinutes + (8.5 * 60);
            const stripTime = terminator.timeMinutes + 15; // Pax deplane
            const finishTime = stripTime + 15 + 30; // Strip + return
            
            if (finishTime > shiftEnd) {
                return false; // Would go past shift end
            }
            
            // Check workload limits
            const maxOps = team.type === 'PT' ? 3 : 7;
            if (workload.count >= maxOps) {
                return false;
            }
            
            // Can add terminator to truck if capacity allows
            // Terminators use 1 truck slot
            if (!canAddToTruck(workload.truckLoad, terminator)) {
                return false;
            }
            
            return true;
        }

        function getTeamTimeWindow(team) {
            // OPTIMIZATION: Return cached time window instead of recalculating
            // The time window is now pre-computed during team extraction
            return team.timeWindow;
        }
        
        function canTeamReachFlight(team, flight) {
            // Check if team's shift timing allows them to service this flight
            // Add 30 min buffer on both ends for flexibility
            const window = getTeamTimeWindow(team);
            const bufferStart = window.start - 30; // Allow 30 min earlier
            const bufferEnd = window.end + 30; // Allow 30 min later
            
            // For short turns, team needs to be available at arrival time
            if (flight.operationType === 'ShortTurn') {
                const arrivalWithBuffer = flight.arrivalTimeMinutes + 15;
                return arrivalWithBuffer >= bufferStart && flight.timeMinutes <= bufferEnd;
            }
            
            // For other flights, check if departure time is in buffered window
            return flight.timeMinutes >= bufferStart && flight.timeMinutes <= bufferEnd;
        }
        
        function canAddToTruck(truckLoad, flight) {
            // International flights always require dedicated truck (max 1)
            if (flight.type === 'International' || flight.type === 'Precleared') {
                return truckLoad.length === 0; // Truck must be empty
            }
            
            // Domestic flights
            // Check if truck already has international (can't mix)
            const hasIntl = truckLoad.some(f => f.type === 'International' || f.type === 'Precleared');
            if (hasIntl) {
                return false; // Can't add domestic to international truck
            }
            
            // INCREASED: Check if truck has space (max 4 domestic)
            return truckLoad.length < 4;
        }
        
        function extractTeams(ftData, ptData, dayOfWeek) {
            const teams = [];
            
            // Column names for Thursday
            const shiftCol = 'Thursday';
            const deptCol = 'Thurs Department';
            const teamCol = 'Thurs Team';

            console.log('Extracting teams for Thursday');
            console.log('Sample FT agent:', ftData[0]);
            console.log('Sample PT agent:', ptData[0]);

            // Process full-time agents
            ftData.forEach(agent => {
                const shift = agent[shiftCol];
                const dept = agent[deptCol];
                const team = agent[teamCol];

                if (shift && shift !== 'Off' && shift !== '' && dept && dept.includes('TRK') && team) {
                    const startTime = shift.split('-')[0];
                    const startMinutes = timeToMinutes(startTime);

                    // OPTIMIZATION: Pre-compute time window to avoid repeated calculations
                    const shiftEnd = startMinutes + (8.5 * 60);
                    const firstAvailable = startMinutes + 60;
                    const lastAvailable = shiftEnd - 70;

                    teams.push({
                        id: team,
                        department: dept,
                        shift: shift,
                        startMinutes: startMinutes,
                        type: 'FT',
                        name: `${agent['First Name']} ${agent['Last Name']}`,
                        specialization: 'mixed', // Default: can do both domestic and international
                        // OPTIMIZATION: Cached time window for O(1) access
                        timeWindow: {
                            start: firstAvailable,
                            end: lastAvailable,
                            startTime: minutesToTime(firstAvailable),
                            endTime: minutesToTime(lastAvailable)
                        }
                    });
                }
            });

            // Process part-time agents
            ptData.forEach(agent => {
                const shift = agent[shiftCol];
                const dept = agent[deptCol];
                const team = agent[teamCol];

                if (shift && shift !== 'Off' && shift !== '' && dept && dept.includes('TRK') && team) {
                    const startTime = shift.split('-')[0];
                    const startMinutes = timeToMinutes(startTime);

                    // OPTIMIZATION: Pre-compute time window to avoid repeated calculations
                    const shiftEnd = startMinutes + (8.5 * 60);
                    const firstAvailable = startMinutes + 60;
                    const lastAvailable = shiftEnd - 70;

                    teams.push({
                        id: team,
                        department: dept,
                        shift: shift,
                        startMinutes: startMinutes,
                        type: 'PT',
                        name: `${agent['First Name']} ${agent['Last Name']}`,
                        specialization: 'mixed', // Default: can do both
                        // OPTIMIZATION: Cached time window for O(1) access
                        timeWindow: {
                            start: firstAvailable,
                            end: lastAvailable,
                            startTime: minutesToTime(firstAvailable),
                            endTime: minutesToTime(lastAvailable)
                        }
                    });
                }
            });
            
            // STRATEGIC SPECIALIZATION: Dedicate some teams to international-only
            // This eliminates long reload buffers and maximizes coverage
            // Strategy: Dedicate 4-5 teams with good timing for international banks
            const intlCandidates = teams.filter(t => 
                t.type === 'FT' && 
                (t.startMinutes <= 360 || (t.startMinutes >= 720 && t.startMinutes <= 840))
            );
            
            // Dedicate first 3 early teams to international
            const earlyIntl = intlCandidates.filter(t => t.startMinutes <= 360).slice(0, 3);
            earlyIntl.forEach(t => t.specialization = 'international');
            
            // Dedicate first 2 afternoon teams to international
            const afternoonIntl = intlCandidates.filter(t => t.startMinutes >= 720 && t.startMinutes <= 840).slice(0, 2);
            afternoonIntl.forEach(t => t.specialization = 'international');
            
            console.log(`Extracted ${teams.length} teams (${earlyIntl.length + afternoonIntl.length} dedicated to international)`);
            if (teams.length > 0) {
                console.log('Sample team:', teams[0]);
            }
            return teams;
        }

        function processFlights(flightData) {
            console.log('Processing flights, total rows:', flightData.length);
            if (flightData.length > 0) {
                console.log('Sample flight data:', flightData[0]);
            }
            
            const departures = [];
            const terminators = [];
            
            flightData.forEach(f => {
                // Process DEPARTURES (has Dep_Flight and Dep_Scheduled)
                if (f.Dep_Flight && f.Dep_Scheduled && f.Dep_Scheduled !== '') {
                    let depTimeStr = f.Dep_Scheduled;
                    if (depTimeStr.includes(' ')) {
                        const parts = depTimeStr.split(' ');
                        depTimeStr = parts[parts.length - 1];
                    }
                    const depTimeMinutes = timeToMinutes(depTimeStr);
                    
                    // Parse arrival time if exists (for turn flights)
                    let arrTimeMinutes = 0;
                    let arrTimeStr = '';
                    if (f.Arr_ETA && f.Arr_ETA !== '') {
                        arrTimeStr = f.Arr_ETA;
                        if (arrTimeStr.includes(' ')) {
                            const parts = arrTimeStr.split(' ');
                            arrTimeStr = parts[parts.length - 1];
                        }
                        arrTimeMinutes = timeToMinutes(arrTimeStr);
                    }
                    
                    // Calculate ground time for turn flights
                    const groundTime = arrTimeMinutes > 0 ? depTimeMinutes - arrTimeMinutes : 0;
                    
                    // Classify flight operation type
                    let operationType = 'Overnight'; // Default
                    if (f.TurnType === 'Overnight') {
                        operationType = 'Overnight';
                    } else if (arrTimeMinutes > 0) {
                        // It's a turn flight
                        if (groundTime <= 180) {
                            operationType = 'ShortTurn'; // ‚â§3 hours, same team strips+loads
                        } else {
                            operationType = 'LongTurn'; // >3 hours, can split strip/load
                        }
                    }
                    
                    if (depTimeMinutes > 0 && depTimeMinutes < 1440) {
                        departures.push({
                            flight: f.Dep_Flight,
                            origin: f.Arr_Origin || 'N/A',
                            destination: f.Dep_Dest || 'N/A',
                            time: depTimeStr,
                            timeMinutes: depTimeMinutes,
                            type: f.Dep_Type || 'Domestic',
                            gate: f.Dep_Gate || f.Arr_Gate || 'TBD',
                            passengers: parseInt(f.Dep_Total_Customers) || parseInt(f.Arr_Total_Customers) || 0,
                            turnType: f.TurnType,
                            equipment: f.Dep_Equip || f.Arr_Equip,
                            arrivalFlight: f.Arr_Flight || '',
                            arrivalTime: arrTimeStr,
                            arrivalTimeMinutes: arrTimeMinutes,
                            groundTime: groundTime,
                            operationType: operationType
                        });
                    }
                }
                
                // Process TERMINATORS (has Arr_Flight but no Dep_Flight, TurnType = "Terminator")
                if (f.TurnType === 'Terminator' && f.Arr_Flight && f.Arr_ETA && f.Arr_ETA !== '') {
                    let arrTimeStr = f.Arr_ETA;
                    if (arrTimeStr.includes(' ')) {
                        const parts = arrTimeStr.split(' ');
                        arrTimeStr = parts[parts.length - 1];
                    }
                    const arrTimeMinutes = timeToMinutes(arrTimeStr);
                    
                    if (arrTimeMinutes > 0 && arrTimeMinutes < 1440) {
                        terminators.push({
                            flight: f.Arr_Flight,
                            origin: f.Arr_Origin || 'N/A',
                            destination: 'PHL',
                            time: arrTimeStr,
                            timeMinutes: arrTimeMinutes,
                            type: f.Arr_Type || 'Domestic',
                            gate: f.Arr_Gate || 'TBD',
                            passengers: parseInt(f.Arr_Total_Customers) || 0,
                            turnType: 'Terminator',
                            equipment: f.Arr_Equip,
                            operationType: 'Terminator'
                        });
                    }
                }
            });
            
            console.log('Processed departures:', departures.length);
            console.log('Processed terminators:', terminators.length);
            
            // Log flight type distribution
            const typeCount = {
                Overnight: departures.filter(f => f.operationType === 'Overnight').length,
                ShortTurn: departures.filter(f => f.operationType === 'ShortTurn').length,
                LongTurn: departures.filter(f => f.operationType === 'LongTurn').length,
                Terminator: terminators.length
            };
            console.log('Flight operation types:', typeCount);
            
            return { departures: departures.sort((a, b) => a.timeMinutes - b.timeMinutes), terminators };
        }

        function assignFlights(flights, teams, assignments, unassigned, teamWorkload, phase) {
            console.log(`\n--- Assigning ${flights.length} flights in phase: ${phase} ---`);
            
            if (flights.length === 0) {
                console.log('No flights to assign in this phase');
                return;
            }
            
            flights.forEach((flight, index) => {
                let assigned = false;
                let bestTeam = null;
                let minWorkload = Infinity;
                let rejectionReasons = [];

                // Find best available team (with least workload)
                for (let team of teams) {
                    const workload = teamWorkload[team.id];
                    
                    // Check if team can handle this flight
                    if (canAssignFlight(team, flight, workload)) {
                        if (workload.count < minWorkload) {
                            minWorkload = workload.count;
                            bestTeam = team;
                        }
                    } else {
                        // Track why we couldn't assign
                        const teamReady = team.startMinutes - 15;
                        if (flight.timeMinutes < teamReady) {
                            rejectionReasons.push(`${team.id}: too early (flight ${flight.timeMinutes} < team ready ${teamReady})`);
                        } else if (workload.count >= 8) {
                            rejectionReasons.push(`${team.id}: full (${workload.count} ops)`);
                        }
                    }
                }

                if (bestTeam) {
                    const workload = teamWorkload[bestTeam.id];
                    assignments.push({
                        flight: flight,
                        team: bestTeam.id,
                        phase: phase
                    });
                    workload.operations.push(flight);
                    workload.count++;
                    assigned = true;
                    
                    if (index < 3) { // Log first few assignments
                        console.log(`‚úì ${flight.flight} (${flight.time}) ‚Üí ${bestTeam.id}`);
                    }
                } else {
                    unassigned.push({
                        flight: flight,
                        reason: 'No available team matching timing and operational constraints'
                    });
                    
                    if (index < 3) { // Log first few failures
                        console.log(`‚úó ${flight.flight} (${flight.time}) - ${rejectionReasons.slice(0, 2).join(', ')}`);
                    }
                }
            });
            
            console.log(`Phase complete: ${flights.filter((f, i) => assignments.some(a => a.flight === f)).length} assigned, ${flights.filter((f, i) => unassigned.some(u => u.flight === f)).length} unassigned`);
        }
        
        function assignFlightsFlexible(flights, teams, assignments, unassigned, teamWorkload, assignedFlights, phase) {
            console.log(`\n=== Phase ${phase}: Attempting ${flights.length} flights ===`);
            let phaseAssigned = 0;

            flights.forEach((flight, index) => {
                let assigned = false;
                let bestTeam = null;
                let minWorkload = Infinity;
                let rejectionReasons = [];

                // Filter teams that can realistically reach this flight based on shift timing
                const eligibleTeams = teams.filter(team => canTeamReachFlight(team, flight));

                if (eligibleTeams.length === 0) {
                    console.log(`‚úó ${flight.flight} (${flight.time}) - NO TEAMS IN TIME WINDOW`);
                    return; // Skip to next flight
                }

                for (let team of eligibleTeams) {
                    const workload = teamWorkload[team.id];

                    if (canAssignFlightFlexible(team, flight, workload)) {
                        if (workload.count < minWorkload) {
                            minWorkload = workload.count;
                            bestTeam = team;
                        }
                    } else {
                        // Track why this team can't take it
                        const reason = getAssignmentBlocker(team, flight, workload, 'flexible');
                        if (reason && index < 5) {
                            rejectionReasons.push(`${team.id}: ${reason}`);
                        }
                    }
                }

                if (bestTeam) {
                    const workload = teamWorkload[bestTeam.id];
                    assignments.push({
                        flight: flight,
                        team: bestTeam.id,
                        phase: phase
                    });
                    assignedFlights.add(flight); // OPTIMIZATION: Track in Set for O(1) lookup
                    workload.operations.push(flight);
                    workload.count++;

                    // Update truck load
                    workload.truckLoad.push(flight);

                    // Check if truck needs to return (3 domestic or 1 international)
                    if (flight.type === 'International' || flight.type === 'Precleared' || workload.truckLoad.length >= 3) {
                        workload.truckLoad = []; // Reset truck - team returns to unit
                    }

                    assigned = true;
                    phaseAssigned++;
                    
                    if (index < 3 || !assigned) {
                        let flightInfo = `${flight.flight} ${flight.operationType} (${flight.time})`;
                        if (flight.operationType === 'ShortTurn' || flight.operationType === 'LongTurn') {
                            flightInfo += ` [ARR: ${flight.arrivalFlight || 'N/A'} ${flight.arrivalTime || 'N/A'}]`;
                        }
                        console.log(`‚úì ${flightInfo} ‚Üí ${bestTeam.id} (ops: ${workload.count})`);
                    }
                } else {
                    // Log why flight couldn't be assigned
                    if (index < 5) {
                        console.log(`‚úó ${flight.flight} ${flight.operationType} (${flight.time}) - ${eligibleTeams.length} eligible teams, none available`);
                        if (rejectionReasons.length > 0) {
                            console.log(`  Reasons: ${rejectionReasons.slice(0, 3).join('; ')}`);
                        }
                    }
                }
            });
            
            console.log(`Phase ${phase} complete: ${phaseAssigned}/${flights.length} assigned`);
        }
        
        function getAssignmentBlocker(team, flight, workload, mode) {
            // Returns reason why team can't take this flight
            
            let earliestAssignTime = team.startMinutes + (mode === 'flexible' ? 45 : 60);
            if (flight.operationType === 'ShortTurn') {
                earliestAssignTime = Math.max(earliestAssignTime, flight.arrivalTimeMinutes + 15);
            }
            
            if (flight.timeMinutes < earliestAssignTime) {
                return `too early (flight ${flight.time} < ready ${minutesToTime(earliestAssignTime)})`;
            }
            
            if (workload.operations.length === 0 && (flight.timeMinutes - team.startMinutes) > 240) {
                return `first flight too late (>4h after shift start)`;
            }
            
            const shiftEnd = team.startMinutes + (8.5 * 60);
            const serviceTime = (flight.type === 'International' || flight.type === 'Precleared') ? 60 : 40;
            const returnTime = 30;
            const latestFlightTime = shiftEnd - serviceTime - returnTime;
            
            if (flight.timeMinutes > latestFlightTime) {
                return `too late (shift ends ${minutesToTime(shiftEnd)})`;
            }
            
            const maxOps = mode === 'flexible' ? (team.type === 'PT' ? 5 : 7) : (team.type === 'PT' ? 4 : 6);
            if (workload.count >= maxOps) {
                return `at capacity (${workload.count}/${maxOps} ops)`;
            }
            
            if (!canAddToTruck(workload.truckLoad, flight)) {
                return `truck full (${workload.truckLoad.length} slots)`;
            }
            
            if (workload.operations.length > 0) {
                const lastOp = workload.operations[workload.operations.length - 1];
                const timeSinceLastOp = flight.timeMinutes - lastOp.timeMinutes;
                
                // BUG FIX: If timeSinceLastOp is negative, flight is BEFORE last op
                // This can happen with overnight operations - should still check buffer
                const actualGap = Math.abs(timeSinceLastOp);
                
                if (lastOp.type === 'Domestic' && flight.type === 'Domestic') {
                    if (actualGap < 30) return `too close to last op (${actualGap}min < 30min)`;
                }
                
                // Specialized international teams
                if (team.specialization === 'international') {
                    if ((lastOp.type === 'International' || lastOp.type === 'Precleared') && 
                        (flight.type === 'International' || flight.type === 'Precleared')) {
                        if (actualGap < 60) return `intl‚Üíintl too close (${actualGap}min < 60min)`;
                    }
                }
                // Mixed teams
                else {
                    if (lastOp.type === 'Domestic' && (flight.type === 'International' || flight.type === 'Precleared')) {
                        if (actualGap < 80) return `need 80min for intl reload (${actualGap}min)`;
                    }
                    
                    if ((lastOp.type === 'International' || lastOp.type === 'Precleared') && flight.type === 'Domestic') {
                        if (actualGap < 80) return `need 80min from intl (${actualGap}min)`;
                    }
                    
                    if ((lastOp.type === 'International' || lastOp.type === 'Precleared') && 
                        (flight.type === 'International' || flight.type === 'Precleared')) {
                        if (actualGap < 110) return `intl‚Üíintl needs 110min (${actualGap}min)`;
                    }
                }
                
                // Block specialized international teams from domestic
                if (team.specialization === 'international' && flight.type === 'Domestic') {
                    return `intl-specialized team (no domestic)`;
                }
            }
            
            return null;
        }
        
        // Very flexible assignment for final sweep - maximum coverage
        function assignFlightsVeryFlexible(flights, teams, assignments, unassigned, teamWorkload, assignedFlights, phase) {
            flights.forEach((flight, index) => {
                let assigned = false;
                let bestTeam = null;
                let minWorkload = Infinity;

                for (let team of teams) {
                    const workload = teamWorkload[team.id];

                    if (canAssignFlightVeryFlexible(team, flight, workload)) {
                        if (workload.count < minWorkload) {
                            minWorkload = workload.count;
                            bestTeam = team;
                        }
                    }
                }

                if (bestTeam) {
                    const workload = teamWorkload[bestTeam.id];
                    assignments.push({
                        flight: flight,
                        team: bestTeam.id,
                        phase: phase
                    });
                    assignedFlights.add(flight); // OPTIMIZATION: Track in Set for O(1) lookup
                    workload.operations.push(flight);
                    workload.count++;

                    // Update truck load
                    workload.truckLoad.push(flight);

                    // Check if truck needs to return
                    if (flight.type === 'International' || flight.type === 'Precleared' || workload.truckLoad.length >= 3) {
                        workload.truckLoad = [];
                    }

                    assigned = true;
                    console.log(`‚úì Final sweep: ${flight.flight} (${flight.time}) ‚Üí ${bestTeam.id}`);
                } else {
                    unassigned.push({
                        flight: flight,
                        reason: 'No team available even with relaxed constraints'
                    });
                    console.log(`‚úó Cannot assign: ${flight.flight} (${flight.time})`);
                }
            });
        }
        
        function canAssignFlightFlexible(team, flight, workload) {
            // For SHORT TURNS: Team must arrive at STA (arrival time)
            let earliestAssignTime = team.startMinutes + 45; // Flexible prep time
            
            if (flight.operationType === 'ShortTurn') {
                earliestAssignTime = Math.max(earliestAssignTime, flight.arrivalTimeMinutes + 15);
            }
            
            if (flight.timeMinutes < earliestAssignTime) return false;
            
            // First flight within 2 hours of shift start (flexible for coverage)
            if (workload.operations.length === 0 && (flight.timeMinutes - team.startMinutes) > 120) {
                return false;
            }
            
            // Calculate shift end - STILL NO OVERTIME
            const shiftEnd = team.startMinutes + (8.5 * 60);
            const serviceTime = (flight.type === 'International' || flight.type === 'Precleared') ? 60 : 40;
            const returnTime = 30;
            const latestFlightTime = shiftEnd - serviceTime - returnTime;
            
            if (flight.timeMinutes > latestFlightTime) return false;

            // Workload limits: Higher for coverage (PT: 3, FT: 7)
            const maxOps = team.type === 'PT' ? 3 : 7;
            if (workload.count >= maxOps) return false;
            
            // Check truck capacity
            if (!canAddToTruck(workload.truckLoad, flight)) {
                return false;
            }

            if (workload.operations.length > 0) {
                const lastOp = workload.operations[workload.operations.length - 1];
                const timeSinceLastOp = flight.timeMinutes - lastOp.timeMinutes;
                
                // Domestic ‚Üí Domestic: Reduced for coverage
                if (lastOp.type === 'Domestic' && flight.type === 'Domestic') {
                    if (timeSinceLastOp < 30) return false;
                }
                
                // Domestic ‚Üí International: Reduced reload time
                if (lastOp.type === 'Domestic' && (flight.type === 'International' || flight.type === 'Precleared')) {
                    if (timeSinceLastOp < 100) return false;
                }
                
                // International ‚Üí Domestic: Reduced reload time
                if ((lastOp.type === 'International' || lastOp.type === 'Precleared') && flight.type === 'Domestic') {
                    if (timeSinceLastOp < 100) return false;
                }
                
                // International ‚Üí International: Reduced cycle
                if ((lastOp.type === 'International' || lastOp.type === 'Precleared') && 
                    (flight.type === 'International' || flight.type === 'Precleared')) {
                    if (timeSinceLastOp < 130) return false;
                }
            }

            return true;
        }
        
        function canAssignFlightVeryFlexible(team, flight, workload) {
            // For SHORT TURNS: Team must arrive at STA
            let earliestAssignTime = team.startMinutes + 30; // Minimum prep time in final sweep
            
            if (flight.operationType === 'ShortTurn') {
                earliestAssignTime = Math.max(earliestAssignTime, flight.arrivalTimeMinutes + 15);
            }
            
            if (flight.timeMinutes < earliestAssignTime) return false;
            
            // In final sweep, remove first flight timing restriction entirely
            // Teams can pick up any flight in their shift window
            
            // STILL NO OVERTIME - shift end is hard limit
            const shiftEnd = team.startMinutes + (8.5 * 60);
            const serviceTime = (flight.type === 'International' || flight.type === 'Precleared') ? 60 : 40;
            const returnTime = 30;
            const latestFlightTime = shiftEnd - serviceTime - returnTime;
            
            if (flight.timeMinutes > latestFlightTime) return false;

            // Final sweep: Maximum coverage (PT: 4, FT: 8)
            const maxOps = team.type === 'PT' ? 4 : 8;
            if (workload.count >= maxOps) return false;
            
            // Check truck capacity
            if (!canAddToTruck(workload.truckLoad, flight)) {
                return false;
            }

            if (workload.operations.length > 0) {
                const lastOp = workload.operations[workload.operations.length - 1];
                const timeSinceLastOp = flight.timeMinutes - lastOp.timeMinutes;
                
                // Domestic ‚Üí Domestic: Minimum realistic buffer
                if (lastOp.type === 'Domestic' && flight.type === 'Domestic') {
                    if (timeSinceLastOp < 25) return false; // Reduced from 30
                }
                
                // Domestic ‚Üí International: Reduced
                if (lastOp.type === 'Domestic' && (flight.type === 'International' || flight.type === 'Precleared')) {
                    if (timeSinceLastOp < 90) return false; // Reduced from 100
                }
                
                // International ‚Üí Domestic: Reduced
                if ((lastOp.type === 'International' || lastOp.type === 'Precleared') && flight.type === 'Domestic') {
                    if (timeSinceLastOp < 90) return false; // Reduced from 100
                }
                
                // International ‚Üí International: Minimum cycle
                if ((lastOp.type === 'International' || lastOp.type === 'Precleared') && 
                    (flight.type === 'International' || flight.type === 'Precleared')) {
                    if (timeSinceLastOp < 120) return false; // Reduced from 130
                }
            }

            return true;
        }

        function canAssignFlight(team, flight, workload) {
            // For SHORT TURNS: Team must arrive at STA (arrival time)
            // They strip (15 min pax + 15 min strip) then load for departure
            let earliestAssignTime = team.startMinutes + 60; // Default prep time
            
            if (flight.operationType === 'ShortTurn') {
                // Team needs to be at gate by STA + 15 min (pax deplane)
                earliestAssignTime = Math.max(earliestAssignTime, flight.arrivalTimeMinutes + 15);
            }
            
            if (flight.timeMinutes < earliestAssignTime) {
                return false;
            }
            
            // First flight within 1 HOUR of shift start (realistic ops window)
            if (workload.operations.length === 0 && (flight.timeMinutes - team.startMinutes) > 60) {
                return false;
            }
            
            // Calculate shift end time - NO OVERTIME ALLOWED
            const shiftEnd = team.startMinutes + (8.5 * 60);
            
            // Flight must complete service and return BEFORE shift end
            const serviceTime = (flight.type === 'International' || flight.type === 'Precleared') ? 60 : 40;
            const returnTime = 30;
            const latestFlightTime = shiftEnd - serviceTime - returnTime;
            
            if (flight.timeMinutes > latestFlightTime) {
                return false;
            }

            // Workload limits - Increase to ensure team utilization
            // PT: 4 flights, FT: 6 flights (will allow more in flexible modes)
            const maxOps = team.type === 'PT' ? 3 : 6;
            if (workload.count >= maxOps) {
                return false;
            }
            
            // Check truck capacity before adding
            if (!canAddToTruck(workload.truckLoad, flight)) {
                return false;
            }

            // Check timing conflicts with last operation
            if (workload.operations.length > 0) {
                const lastOp = workload.operations[workload.operations.length - 1];
                const timeSinceLastOp = flight.timeMinutes - lastOp.timeMinutes;
                
                // Handle negative gaps (overnight operations)
                if (timeSinceLastOp < 0) return false; // Can't go backwards in time
                
                // REALISTIC BUFFERS - Operations already on truck vs need reload
                
                // Check if we need to reload truck
                const needsReload = !canAddToTruck(workload.truckLoad, flight);
                
                if (flight.type === 'Domestic' && lastOp.type === 'Domestic') {
                    if (needsReload) {
                        // Need to return to base and reload
                        if (timeSinceLastOp < 45) return false; // 30 min return + 15 min reload
                    } else {
                        // Flights already on truck - just drive time between gates
                        if (timeSinceLastOp < 15) return false; // Gate to gate + service
                    }
                }
                
                // International specialized teams: minimal buffer (same area)
                if (team.specialization === 'international') {
                    if ((lastOp.type === 'International' || lastOp.type === 'Precleared') && 
                        (flight.type === 'International' || flight.type === 'Precleared')) {
                        if (timeSinceLastOp < 50) return false; // Service + gate positioning
                    }
                }
                // Mixed teams doing international
                else {
                    if (lastOp.type === 'Domestic' && (flight.type === 'International' || flight.type === 'Precleared')) {
                        if (timeSinceLastOp < 70) return false; // Return + reload intl cart + drive
                    }
                    
                    if ((lastOp.type === 'International' || lastOp.type === 'Precleared') && flight.type === 'Domestic') {
                        if (timeSinceLastOp < 70) return false; // Return + reload domestic + drive
                    }
                    
                    if ((lastOp.type === 'International' || lastOp.type === 'Precleared') && 
                        (flight.type === 'International' || flight.type === 'Precleared')) {
                        if (timeSinceLastOp < 90) return false; // Return + reload another intl + drive
                    }
                }
                
                // Block specialized international teams from domestic
                if (team.specialization === 'international' && flight.type === 'Domestic') {
                    return false;
                }
            }

            return true;
        }

        function calculateStats(assignments, unassigned, departures, terminators, teams) {
            const departureAssignments = assignments.filter(a => !a.operation || a.operation !== 'strip');
            const terminatorAssignments = assignments.filter(a => a.operation === 'strip');
            
            const domestic = departureAssignments.filter(a => a.flight.type === 'Domestic').length;
            const international = departureAssignments.filter(a => a.flight.type === 'International').length;
            const shortTurns = departureAssignments.filter(a => a.flight.operationType === 'ShortTurn').length;

            // Focus on DEPARTURES for coverage, terminators are BONUS
            const totalDepartures = departures.length;
            const unassignedDepartures = unassigned.filter(u => !u.flight.operationType || u.flight.operationType !== 'Terminator');
            
            return {
                totalFlights: totalDepartures,
                assigned: departureAssignments.length,
                unassigned: unassignedDepartures.length,
                domestic: domestic,
                international: international,
                shortTurns: shortTurns,
                terminatorsTotal: terminators.length,
                terminatorsAssigned: terminatorAssignments.length,
                terminatorCoverage: terminators.length > 0 ? Math.round((terminatorAssignments.length / terminators.length) * 100) : 0,
                teamsDeployed: teams.length,
                coveragePercent: Math.round((departureAssignments.length / totalDepartures) * 100)
            };
        }

        function timeToMinutes(timeStr) {
            if (!timeStr || timeStr === '') return 0;
            
            // Remove any whitespace
            timeStr = timeStr.trim();
            
            // Handle full datetime format like "1/0/1900 23:55"
            if (timeStr.includes('/')) {
                const parts = timeStr.split(' ');
                if (parts.length > 1) {
                    timeStr = parts[1]; // Get the time part
                } else {
                    return 0; // Invalid format
                }
            }
            
            // Handle time with AM/PM
            if (timeStr.includes('AM') || timeStr.includes('PM')) {
                const isPM = timeStr.includes('PM');
                timeStr = timeStr.replace(/AM|PM/g, '').trim();
                const parts = timeStr.split(':');
                let hours = parseInt(parts[0]);
                const mins = parseInt(parts[1] || 0);
                
                if (isPM && hours !== 12) hours += 12;
                if (!isPM && hours === 12) hours = 0;
                
                return hours * 60 + mins;
            }
            
            // Handle 24-hour format with colon (HH:MM or H:MM)
            if (timeStr.includes(':')) {
                const parts = timeStr.split(':');
                const hours = parseInt(parts[0]);
                const mins = parseInt(parts[1] || 0);
                
                if (isNaN(hours) || isNaN(mins)) return 0;
                return hours * 60 + mins;
            }
            
            // Handle 4-digit format without colon (HHMM like "0500" or "1330")
            if (timeStr.length === 4 && !isNaN(timeStr)) {
                const hours = parseInt(timeStr.substring(0, 2));
                const mins = parseInt(timeStr.substring(2, 4));
                
                if (isNaN(hours) || isNaN(mins)) return 0;
                return hours * 60 + mins;
            }
            
            // Handle 3-digit format (HMM like "500" for 5:00)
            if (timeStr.length === 3 && !isNaN(timeStr)) {
                const hours = parseInt(timeStr.substring(0, 1));
                const mins = parseInt(timeStr.substring(1, 3));
                
                if (isNaN(hours) || isNaN(mins)) return 0;
                return hours * 60 + mins;
            }
            
            // Handle 1 or 2 digit format (just hours)
            if ((timeStr.length === 1 || timeStr.length === 2) && !isNaN(timeStr)) {
                const hours = parseInt(timeStr);
                if (isNaN(hours)) return 0;
                return hours * 60;
            }
            
            console.warn(`Unable to parse time: "${timeStr}"`);
            return 0;
        }

        function minutesToTime(minutes) {
            const hours = Math.floor(minutes / 60);
            const mins = minutes % 60;
            return `${hours.toString().padStart(2, '0')}:${mins.toString().padStart(2, '0')}`;
        }

        // Display results
        function displayResults(result) {
            // Display header with day of week
            const statsGrid = document.getElementById('statsGrid');
            statsGrid.innerHTML = `
                <div class="stat-card" style="grid-column: span 2; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white;">
                    <h3 style="color: rgba(255,255,255,0.9);">Scheduling Day</h3>
                    <div class="value" style="color: white;">${result.dayOfWeek}</div>
                </div>
                <div class="stat-card">
                    <h3>Total Operations</h3>
                    <div class="value">${result.stats.totalFlights}</div>
                </div>
                <div class="stat-card">
                    <h3>Assigned</h3>
                    <div class="value" style="color: #28a745;">${result.stats.assigned}</div>
                </div>
                <div class="stat-card">
                    <h3>Coverage</h3>
                    <div class="value">${result.stats.coveragePercent}%</div>
                </div>
                <div class="stat-card">
                    <h3>Short Turns</h3>
                    <div class="value">${result.stats.shortTurns}</div>
                </div>
                <div class="stat-card" style="background: linear-gradient(135deg, #d4edda 0%, #c3e6cb 100%); border-left-color: #28a745;">
                    <h3>Terminators (Strips)</h3>
                    <div class="value" style="color: #155724;">${result.stats.terminatorsAssigned} / ${result.stats.terminatorsTotal}</div>
                    <div style="font-size: 0.7em; color: #155724; margin-top: 5px;">${result.stats.terminatorCoverage}% coverage</div>
                </div>
                <div class="stat-card">
                    <h3>International</h3>
                    <div class="value">${result.stats.international}</div>
                </div>
                <div class="stat-card">
                    <h3>Teams Deployed</h3>
                    <div class="value">${result.stats.teamsDeployed}</div>
                </div>
            `;
            
            // Show coverage gap alert if exists
            if (result.coverageGaps && Object.keys(result.coverageGaps).length > 0) {
                const gapHours = Object.keys(result.coverageGaps).sort((a,b) => a-b);
                const gapSummary = gapHours.map(h => `${h}:00 (${result.coverageGaps[h].length})`).join(', ');
                statsGrid.innerHTML += `
                    <div class="stat-card" style="grid-column: span 4; background: #fff3cd; border-left: 4px solid #ffc107;">
                        <h3 style="color: #856404;">Coverage Gaps by Hour</h3>
                        <div style="font-size: 0.9em; color: #856404; margin-top: 8px;">${gapSummary}</div>
                    </div>
                `;
            }

            // Show idle team alert
            if (result.idleTeams && result.idleTeams.length > 0) {
                statsGrid.innerHTML += `
                    <div class="stat-card" style="grid-column: span 4; background: #f8d7da; border-left: 4px solid #dc3545;">
                        <h3 style="color: #721c24;">‚ö†Ô∏è Idle Teams (${result.idleTeams.length})</h3>
                        <div style="font-size: 0.9em; color: #721c24; margin-top: 8px;">${result.idleTeams.join(', ')}</div>
                    </div>
                `;
            }
            
            // Show buffer violation alert
            if (result.bufferViolations && result.bufferViolations.length > 0) {
                const violationSummary = result.bufferViolations.map(v => 
                    `${v.team}: ${v.flight1}‚Üí${v.flight2} (${v.bufferType}: ${v.actualBuffer}/${v.requiredBuffer}min)`
                ).join('<br>');
                
                statsGrid.innerHTML += `
                    <div class="stat-card" style="grid-column: span 4; background: #f8d7da; border-left: 4px solid #dc3545;">
                        <h3 style="color: #721c24;">‚ö†Ô∏è Buffer Violations (${result.bufferViolations.length})</h3>
                        <div style="font-size: 0.85em; color: #721c24; margin-top: 8px; line-height: 1.6;">${violationSummary}</div>
                    </div>
                `;
            }

            // Display team workload
            const teamTableBody = document.getElementById('teamTableBody');
            teamTableBody.innerHTML = '';
            result.teamWorkload.forEach(tw => {
                const firstFlight = tw.operations[0];
                const lastFlight = tw.operations[tw.operations.length - 1];
                const flightNumbers = tw.operations.map(op => op.flight).join(', ');
                
                // Calculate shift end and when last flight finishes
                const shiftEnd = tw.team.startMinutes + (8.5 * 60);
                const shiftEndTime = minutesToTime(shiftEnd);
                const lastFlightFinish = lastFlight ? lastFlight.timeMinutes + ((lastFlight.type === 'International' || lastFlight.type === 'Precleared') ? 60 : 40) + 30 : 0;
                const finishTime = lastFlight ? minutesToTime(lastFlightFinish) : '-';
                const withinShift = lastFlightFinish <= shiftEnd;
                
                const row = `
                    <tr>
                        <td><strong>${tw.team.id}</strong> <span style="font-size: 0.8em; color: #6c757d;">(${tw.team.type})</span></td>
                        <td>${tw.team.shift}</td>
                        <td>${tw.count}</td>
                        <td>
                            <div class="workload-bar">
                                <div class="workload-fill" style="width: ${(tw.count / 6) * 100}%"></div>
                            </div>
                        </td>
                        <td style="font-size: 0.85em; max-width: 300px; overflow-x: auto;">${flightNumbers || '-'}</td>
                        <td>${firstFlight ? firstFlight.time : '-'}</td>
                        <td>${lastFlight ? lastFlight.time : '-'}</td>
                        <td>${finishTime} ${withinShift ? '<span style="color: #28a745;">‚úì</span>' : '<span style="color: #dc3545;">‚ö†Ô∏è</span>'}</td>
                    </tr>
                `;
                teamTableBody.innerHTML += row;
            });
            
            // Add OVERNIGHT row if there are overnight assignments
            const overnightFlights = result.assignments.filter(a => a.team === 'OVERNIGHT');
            if (overnightFlights.length > 0) {
                const overnightNumbers = overnightFlights.map(a => a.flight.flight).join(', ');
                const firstOvernight = overnightFlights[0].flight;
                const lastOvernight = overnightFlights[overnightFlights.length - 1].flight;
                const row = `
                    <tr style="background: #fff3cd;">
                        <td><strong>OVERNIGHT</strong></td>
                        <td>Previous Day</td>
                        <td>${overnightFlights.length}</td>
                        <td>
                            <div class="workload-bar">
                                <div class="workload-fill" style="width: ${(overnightFlights.length / 6) * 100}%; background: #ffc107;"></div>
                            </div>
                        </td>
                        <td style="font-size: 0.85em;">${overnightNumbers}</td>
                        <td>${firstOvernight.time}</td>
                        <td>${lastOvernight.time}</td>
                    </tr>
                `;
                teamTableBody.innerHTML = row + teamTableBody.innerHTML; // Add at top
            }
            
            // Generate detailed team groupings
            generateTeamDetailedView(result);

            // Display flight assignments with editable team assignments
            const flightTableBody = document.getElementById('flightTableBody');
            flightTableBody.innerHTML = '';
            
            // Get list of all teams for dropdown
            const allTeams = [...new Set(result.teamWorkload.map(tw => tw.team.id))].sort();
            allTeams.unshift('OVERNIGHT'); // Add overnight option
            
            result.assignments.forEach((a, index) => {
                const teamDropdown = allTeams.map(teamId => 
                    `<option value="${teamId}" ${teamId === a.team ? 'selected' : ''}>${teamId}</option>`
                ).join('');
                
                // Display operation type badge
                let opTypeBadge = '';
                if (a.flight.operationType === 'ShortTurn') {
                    opTypeBadge = '<span class="flight-detail-badge" style="background: #17a2b8; color: white;">Short Turn</span>';
                } else if (a.flight.operationType === 'LongTurn') {
                    opTypeBadge = '<span class="flight-detail-badge" style="background: #6c757d; color: white;">Long Turn</span>';
                } else if (a.flight.operationType === 'Terminator') {
                    opTypeBadge = '<span class="flight-detail-badge" style="background: #ffc107; color: #000;">Terminator</span>';
                } else if (a.flight.operationType === 'Overnight') {
                    opTypeBadge = '<span class="flight-detail-badge" style="background: #28a745; color: white;">Overnight</span>';
                }
                
                const row = `
                    <tr data-assignment-index="${index}">
                        <td><strong>${a.flight.flight}</strong> ${opTypeBadge}</td>
                        <td>${a.flight.destination}</td>
                        <td>${a.flight.time}</td>
                        <td><span class="status-badge status-${a.flight.type.toLowerCase()}">${a.flight.type}</span></td>
                        <td>
                            <select class="team-selector" onchange="updateAssignment(${index}, this.value)">
                                ${teamDropdown}
                            </select>
                        </td>
                        <td>${a.flight.gate}</td>
                    </tr>
                `;
                flightTableBody.innerHTML += row;
            });

            // Display unassigned flights
            if (result.unassigned.length > 0) {
                document.getElementById('unassignedSection').style.display = 'block';
                document.getElementById('unassignedAlert').textContent = 
                    `${result.unassigned.length} flights could not be assigned. Consider adding overtime or split shifts.`;
                
                const unassignedTableBody = document.getElementById('unassignedTableBody');
                unassignedTableBody.innerHTML = '';
                result.unassigned.forEach(u => {
                    const row = `
                        <tr>
                            <td><strong>${u.flight.flight}</strong></td>
                            <td>${u.flight.destination}</td>
                            <td>${u.flight.time}</td>
                            <td><span class="status-badge status-${u.flight.type.toLowerCase()}">${u.flight.type}</span></td>
                            <td>${u.reason}</td>
                        </tr>
                    `;
                    unassignedTableBody.innerHTML += row;
                });
            }
        }

        // Export to Excel
        document.getElementById('exportBtn').addEventListener('click', exportToExcel);
        
        // Handle assignment changes
        function updateAssignment(index, newTeam) {
            if (!scheduleResult) return;
            
            const assignment = scheduleResult.assignments[index];
            const oldTeam = assignment.team;
            
            // Update the assignment
            assignment.team = newTeam;
            
            // Recalculate team workloads
            scheduleResult.teamWorkload.forEach(tw => {
                // Remove from old team
                if (tw.team.id === oldTeam) {
                    tw.operations = tw.operations.filter(op => op !== assignment.flight);
                    tw.count = tw.operations.length;
                }
                // Add to new team (only if it's not OVERNIGHT)
                if (tw.team.id === newTeam) {
                    tw.operations.push(assignment.flight);
                    tw.operations.sort((a, b) => a.timeMinutes - b.timeMinutes);
                    tw.count = tw.operations.length;
                }
            });
            
            // Refresh the team workload display
            updateTeamWorkloadDisplay();
            
            console.log(`Updated: ${assignment.flight.flight} from ${oldTeam} to ${newTeam}`);
        }
        
        function generateTeamDetailedView(result) {
            const container = document.getElementById('teamDetailedGroups');
            container.innerHTML = '';
            
            // First add OVERNIGHT if it exists
            const overnightFlights = result.assignments.filter(a => a.team === 'OVERNIGHT');
            if (overnightFlights.length > 0) {
                const overnightCard = createTeamDetailCard('OVERNIGHT', 'Previous Day (23:00-05:00)', overnightFlights, true);
                container.innerHTML += overnightCard;
            }
            
            // Then add all regular teams sorted by shift start time
            const sortedTeams = [...result.teamWorkload].sort((a, b) => a.team.startMinutes - b.team.startMinutes);
            
            sortedTeams.forEach(tw => {
                if (tw.count > 0) {
                    const teamAssignments = result.assignments.filter(a => a.team === tw.team.id);
                    const teamCard = createTeamDetailCard(tw.team.id, tw.team.shift, teamAssignments, false);
                    container.innerHTML += teamCard;
                }
            });
        }
        
        function createTeamDetailCard(teamId, shift, assignments, isOvernight) {
            const flights = assignments.map(a => a.flight).sort((a, b) => a.timeMinutes - b.timeMinutes);
            const firstFlight = flights[0];
            const lastFlight = flights[flights.length - 1];
            
            // Calculate timing details
            const totalSpan = lastFlight ? ((lastFlight.timeMinutes - firstFlight.timeMinutes) / 60).toFixed(1) : '0';
            const avgGap = flights.length > 1 ? 
                ((lastFlight.timeMinutes - firstFlight.timeMinutes) / (flights.length - 1)).toFixed(0) : 'N/A';
            
            // Calculate buffers between flights
            const buffers = [];
            for (let i = 1; i < flights.length; i++) {
                const gap = flights[i].timeMinutes - flights[i-1].timeMinutes;
                buffers.push(gap);
            }
            const avgBuffer = buffers.length > 0 ? (buffers.reduce((a,b) => a+b, 0) / buffers.length).toFixed(0) : 'N/A';
            const minBuffer = buffers.length > 0 ? Math.min(...buffers) : 'N/A';
            
            // Calculate shift end and finish time
            const teamType = assignments[0]?.team || 'FT';
            let shiftEndTime = 'N/A';
            let finishTime = 'N/A';
            let statusIcon = '';
            
            if (!isOvernight && shift.includes('-')) {
                const shiftStartStr = shift.split('-')[0];
                const shiftStartMinutes = timeToMinutes(shiftStartStr);
                const shiftEndMinutes = shiftStartMinutes + (8.5 * 60);
                shiftEndTime = minutesToTime(shiftEndMinutes);
                
                if (lastFlight) {
                    const serviceTime = (lastFlight.type === 'International' || lastFlight.type === 'Precleared') ? 60 : 40;
                    const returnTime = 30;
                    const finishMinutes = lastFlight.timeMinutes + serviceTime + returnTime;
                    finishTime = minutesToTime(finishMinutes);
                    
                    if (finishMinutes <= shiftEndMinutes) {
                        statusIcon = '<span style="color: #28a745; font-size: 1.2em; margin-left: 5px;">‚úì</span>';
                    } else {
                        statusIcon = '<span style="color: #dc3545; font-size: 1.2em; margin-left: 5px;">‚ö†Ô∏è</span>';
                    }
                }
            }
            
            const flightRows = assignments.map((assignment, idx) => {
                const flight = assignment.flight;
                const buffer = idx > 0 ? `${flight.timeMinutes - flights[idx-1].timeMinutes} min` : '-';
                const isTerminator = assignment.operation === 'strip';
                const opType = isTerminator ? '<span style="background: #fff3cd; color: #856404; padding: 2px 6px; border-radius: 3px; font-size: 0.75em; font-weight: 600;">STRIP</span>' : '';
                
                return `
                    <tr ${isTerminator ? 'style="background: #fffdf0;"' : ''}>
                        <td>${idx + 1}</td>
                        <td><strong>${flight.flight}</strong> ${opType}</td>
                        <td>${flight.destination || flight.origin || 'N/A'}</td>
                        <td><strong>${flight.time}</strong></td>
                        <td><span class="status-badge status-${flight.type.toLowerCase()}">${flight.type}</span></td>
                        <td>${flight.gate}</td>
                        <td>${flight.passengers || 'N/A'}</td>
                        <td>${flight.equipment || 'N/A'}</td>
                        <td>${buffer}</td>
                    </tr>
                `;
            }).join('');
            
            return `
                <div class="team-detail-card ${isOvernight ? 'overnight-card' : ''}">
                    <div class="team-detail-header">
                        <div>
                            <h3>${teamId}</h3>
                            <div style="opacity: 0.9; margin-top: 5px;">Shift: ${shift} ${!isOvernight && shift.includes('-') ? `| Ends: ${shiftEndTime}` : ''}</div>
                        </div>
                        <div class="team-detail-info">
                            <div class="team-detail-info-item">
                                <label>Operations</label>
                                <value>${flights.length}</value>
                            </div>
                            <div class="team-detail-info-item">
                                <label>Time Span</label>
                                <value>${totalSpan} hrs</value>
                            </div>
                            <div class="team-detail-info-item">
                                <label>Avg Buffer</label>
                                <value>${avgBuffer} min</value>
                            </div>
                            <div class="team-detail-info-item">
                                <label>Min Buffer</label>
                                <value>${minBuffer} min</value>
                            </div>
                            <div class="team-detail-info-item">
                                <label>First Flight</label>
                                <value>${firstFlight.time}</value>
                            </div>
                            <div class="team-detail-info-item">
                                <label>Last Flight</label>
                                <value>${lastFlight.time}</value>
                            </div>
                            <div class="team-detail-info-item">
                                <label>Finish Time</label>
                                <value>${finishTime}${statusIcon}</value>
                            </div>
                        </div>
                    </div>
                    <table class="team-flights-table">
                        <thead>
                            <tr>
                                <th>#</th>
                                <th>Flight</th>
                                <th>Destination</th>
                                <th>STD</th>
                                <th>Type</th>
                                <th>Gate</th>
                                <th>PAX</th>
                                <th>Equipment</th>
                                <th>Buffer</th>
                            </tr>
                        </thead>
                        <tbody>
                            ${flightRows}
                        </tbody>
                    </table>
                </div>
            `;
        }
        
        function updateTeamWorkloadDisplay() {
            const teamTableBody = document.getElementById('teamTableBody');
            teamTableBody.innerHTML = '';
            
            scheduleResult.teamWorkload.forEach(tw => {
                const firstFlight = tw.operations[0];
                const lastFlight = tw.operations[tw.operations.length - 1];
                const flightNumbers = tw.operations.map(op => op.flight).join(', ');
                const row = `
                    <tr>
                        <td><strong>${tw.team.id}</strong></td>
                        <td>${tw.team.shift}</td>
                        <td>${tw.count}</td>
                        <td>
                            <div class="workload-bar">
                                <div class="workload-fill" style="width: ${(tw.count / 6) * 100}%"></div>
                            </div>
                        </td>
                        <td style="font-size: 0.85em;">${flightNumbers || '-'}</td>
                        <td>${firstFlight ? firstFlight.time : '-'}</td>
                        <td>${lastFlight ? lastFlight.time : '-'}</td>
                    </tr>
                `;
                teamTableBody.innerHTML += row;
            });
            
            // Add OVERNIGHT row
            const overnightFlights = scheduleResult.assignments.filter(a => a.team === 'OVERNIGHT');
            if (overnightFlights.length > 0) {
                const overnightNumbers = overnightFlights.map(a => a.flight.flight).join(', ');
                const firstOvernight = overnightFlights[0].flight;
                const lastOvernight = overnightFlights[overnightFlights.length - 1].flight;
                const row = `
                    <tr style="background: #fff3cd;">
                        <td><strong>OVERNIGHT</strong></td>
                        <td>Previous Day</td>
                        <td>${overnightFlights.length}</td>
                        <td>
                            <div class="workload-bar">
                                <div class="workload-fill" style="width: ${(overnightFlights.length / 6) * 100}%; background: #ffc107;"></div>
                            </div>
                        </td>
                        <td style="font-size: 0.85em;">${overnightNumbers}</td>
                        <td>${firstOvernight.time}</td>
                        <td>${lastOvernight.time}</td>
                    </tr>
                `;
                teamTableBody.innerHTML = row + teamTableBody.innerHTML;
            }
        }
        
        // Make updateAssignment globally available
        window.updateAssignment = updateAssignment;
        
        // AI Chat Assistant
        async function sendChatMessage() {
            const input = document.getElementById('chatInput');
            const message = input.value.trim();
            
            if (!message) return;
            if (!scheduleResult) {
                addChatMessage('Please generate a schedule first!', 'error');
                return;
            }
            
            // Clear input and disable button
            input.value = '';
            const sendBtn = document.getElementById('sendChatBtn');
            sendBtn.disabled = true;
            sendBtn.textContent = '‚è≥ Thinking...';
            
            // Show user message
            addChatMessage(message, 'user');
            
            try {
                // Process the request locally using pattern matching
                const result = await processScheduleRequest(message);
                
                if (result.success) {
                    addChatMessage(result.message, 'success');
                    
                    // Apply changes if any
                    if (result.changes && result.changes.length > 0) {
                        result.changes.forEach(change => {
                            updateAssignment(change.index, change.newTeam);
                        });
                    }
                    
                    // Refresh display
                    displayResults(scheduleResult);
                } else {
                    addChatMessage(result.message, 'assistant');
                }
            } catch (error) {
                addChatMessage('Sorry, I encountered an error: ' + error.message, 'error');
            }
            
            // Re-enable button
            sendBtn.disabled = false;
            sendBtn.textContent = '‚ú® Send Request';
        }
        
        function addChatMessage(text, type) {
            const messagesDiv = document.getElementById('chatMessages');
            const messageDiv = document.createElement('div');
            messageDiv.className = `chat-message ${type}`;
            messageDiv.textContent = text;
            messagesDiv.appendChild(messageDiv);
            messagesDiv.scrollTop = messagesDiv.scrollHeight;
        }
        
        async function processScheduleRequest(message) {
            const lowerMessage = message.toLowerCase();
            
            // Pattern 1: Move specific flight to team
            const movePattern = /move.*flight\s+(\d+).*to\s+(tm\d+|overnight)/i;
            const moveMatch = message.match(movePattern);
            
            if (moveMatch) {
                const flightNum = moveMatch[1];
                const targetTeam = moveMatch[2].toUpperCase();
                
                const assignmentIndex = scheduleResult.assignments.findIndex(a => 
                    a.flight.flight.includes(flightNum)
                );
                
                if (assignmentIndex === -1) {
                    return {
                        success: false,
                        message: `Flight ${flightNum} not found in current assignments. It may be unassigned.`
                    };
                }
                
                const assignment = scheduleResult.assignments[assignmentIndex];
                const oldTeam = assignment.team;
                
                return {
                    success: true,
                    message: `‚úì Moved flight ${flightNum} from ${oldTeam} to ${targetTeam}`,
                    changes: [{ index: assignmentIndex, newTeam: targetTeam }]
                };
            }
            
            // Pattern 2: Show overloaded teams
            if (lowerMessage.includes('overload') || lowerMessage.includes('too many')) {
                const overloaded = scheduleResult.teamWorkload
                    .filter(tw => tw.count > 6)
                    .map(tw => `${tw.team.id}: ${tw.count} operations`)
                    .join(', ');
                
                if (overloaded) {
                    return {
                        success: false,
                        message: `Overloaded teams (>6 ops): ${overloaded}`
                    };
                } else {
                    return {
                        success: false,
                        message: 'No teams are currently overloaded (all have ‚â§6 operations)'
                    };
                }
            }
            
            // Pattern 3: Show underutilized teams
            if (lowerMessage.includes('underutilized') || lowerMessage.includes('under')) {
                const underutilized = scheduleResult.teamWorkload
                    .filter(tw => tw.count < 3 && tw.count > 0)
                    .map(tw => `${tw.team.id}: ${tw.count} operations`)
                    .join(', ');
                
                if (underutilized) {
                    return {
                        success: false,
                        message: `Underutilized teams (<3 ops): ${underutilized}`
                    };
                } else {
                    return {
                        success: false,
                        message: 'All teams have adequate workload (‚â•3 operations)'
                    };
                }
            }
            
            // Pattern 4: Balance workload
            if (lowerMessage.includes('balance')) {
                // Find most overloaded and least loaded teams
                const sorted = [...scheduleResult.teamWorkload].sort((a, b) => b.count - a.count);
                const mostLoaded = sorted[0];
                const leastLoaded = sorted[sorted.length - 1];
                
                if (mostLoaded.count - leastLoaded.count <= 2) {
                    return {
                        success: false,
                        message: 'Schedule is already well balanced. Max difference is ‚â§2 operations.'
                    };
                }
                
                return {
                    success: false,
                    message: `Workload spread: ${mostLoaded.team.id} has ${mostLoaded.count} ops, ${leastLoaded.team.id} has ${leastLoaded.count} ops. Consider manually moving flights between them.`
                };
            }
            
            // Pattern 5: Reassign all flights from one team to another
            const reassignPattern = /reassign.*from\s+(tm\d+).*to\s+(tm\d+)/i;
            const reassignMatch = message.match(reassignPattern);
            
            if (reassignMatch) {
                const fromTeam = reassignMatch[1].toUpperCase();
                const toTeam = reassignMatch[2].toUpperCase();
                
                const changes = [];
                scheduleResult.assignments.forEach((a, index) => {
                    if (a.team === fromTeam) {
                        changes.push({ index, newTeam: toTeam });
                    }
                });
                
                if (changes.length === 0) {
                    return {
                        success: false,
                        message: `No flights found assigned to ${fromTeam}`
                    };
                }
                
                return {
                    success: true,
                    message: `‚úì Reassigned ${changes.length} flights from ${fromTeam} to ${toTeam}`,
                    changes: changes
                };
            }
            
            // Pattern 6: Show team details
            const teamPattern = /show.*team\s+(tm\d+|overnight)/i;
            const teamMatch = message.match(teamPattern);
            
            if (teamMatch) {
                const teamId = teamMatch[1].toUpperCase();
                const teamWorkload = scheduleResult.teamWorkload.find(tw => tw.team.id === teamId);
                
                if (!teamWorkload) {
                    const overnightFlights = scheduleResult.assignments.filter(a => a.team === 'OVERNIGHT');
                    if (teamId === 'OVERNIGHT' && overnightFlights.length > 0) {
                        const flights = overnightFlights.map(a => 
                            `${a.flight.flight} (${a.flight.time} to ${a.flight.destination})`
                        ).join(', ');
                        return {
                            success: false,
                            message: `OVERNIGHT: ${overnightFlights.length} flights - ${flights}`
                        };
                    }
                    return {
                        success: false,
                        message: `Team ${teamId} not found`
                    };
                }
                
                const flights = teamWorkload.operations.map(op => 
                    `${op.flight} (${op.time} to ${op.destination})`
                ).join(', ');
                
                return {
                    success: false,
                    message: `${teamId}: ${teamWorkload.count} operations - ${flights}`
                };
            }
            
            // Default response
            return {
                success: false,
                message: "I can help you with:\n‚Ä¢ Move flight [number] to [team]\n‚Ä¢ Show team [team]\n‚Ä¢ Show overloaded/underutilized teams\n‚Ä¢ Reassign flights from [team] to [team]\n‚Ä¢ Balance workload"
            };
        }
        
        // Allow Enter key to send message
        document.addEventListener('DOMContentLoaded', () => {
            const chatInput = document.getElementById('chatInput');
            if (chatInput) {
                chatInput.addEventListener('keydown', (e) => {
                    if (e.key === 'Enter' && !e.shiftKey) {
                        e.preventDefault();
                        sendChatMessage();
                    }
                });
            }
        });
        
        window.sendChatMessage = sendChatMessage;

        function exportToExcel() {
            if (!scheduleResult) return;

            const wb = XLSX.utils.book_new();
            
            // ==================== TAB 1: SUMMARY ====================
            const summaryData = [
                ['PHL CATERING FLIGHT SCHEDULER'],
                ['Schedule Date:', scheduleResult.dayOfWeek],
                ['Generated:', new Date().toLocaleString()],
                [''],
                ['COVERAGE STATISTICS'],
                ['Total Departures:', scheduleResult.stats.totalFlights],
                ['Assigned Departures:', scheduleResult.stats.assigned],
                ['Unassigned Departures:', scheduleResult.stats.unassigned],
                ['Departure Coverage:', scheduleResult.stats.coveragePercent + '%'],
                [''],
                ['Domestic Flights:', scheduleResult.stats.domestic],
                ['International Flights:', scheduleResult.stats.international],
                ['Short Turns:', scheduleResult.stats.shortTurns],
                [''],
                ['TERMINATOR STRIPS (BONUS)'],
                ['Total Terminators:', scheduleResult.stats.terminatorsTotal],
                ['Assigned Terminators:', scheduleResult.stats.terminatorsAssigned],
                ['Terminator Coverage:', scheduleResult.stats.terminatorCoverage + '%'],
                [''],
                ['TEAM DEPLOYMENT'],
                ['Teams Deployed:', scheduleResult.stats.teamsDeployed],
                ['Idle Teams:', scheduleResult.idleTeams ? scheduleResult.idleTeams.length : 0],
                [''],
                ['BUFFER VIOLATIONS'],
                ['Total Violations:', scheduleResult.bufferViolations ? scheduleResult.bufferViolations.length : 0]
            ];
            
            const summarySheet = XLSX.utils.aoa_to_sheet(summaryData);
            // Set column widths
            summarySheet['!cols'] = [{ wch: 25 }, { wch: 20 }];
            XLSX.utils.book_append_sheet(wb, summarySheet, 'Summary');

            // ==================== TAB 2: TEAM SCHEDULE (Detailed) ====================
            const teamScheduleData = [];
            
            // Sort teams by shift start time
            const sortedTeams = [...scheduleResult.teamWorkload].sort((a, b) => 
                a.team.startMinutes - b.team.startMinutes
            );
            
            sortedTeams.forEach(tw => {
                if (tw.count === 0) return; // Skip idle teams
                
                // Team header
                teamScheduleData.push({
                    'Team': tw.team.id,
                    'Type': tw.team.type,
                    'Department': tw.team.department,
                    'Shift': tw.team.shift,
                    'Operations': tw.count,
                    'Flight': '',
                    'Dest/Origin': '',
                    'STD/STA': '',
                    'Flight Type': '',
                    'Gate': '',
                    'PAX': '',
                    'Equipment': '',
                    'Operation': '',
                    'Buffer (min)': ''
                });
                
                // Sort operations by time
                const sortedOps = [...tw.operations].sort((a, b) => a.timeMinutes - b.timeMinutes);
                
                sortedOps.forEach((op, idx) => {
                    const assignment = scheduleResult.assignments.find(a => a.flight === op && a.team === tw.team.id);
                    const isTerminator = assignment && assignment.operation === 'strip';
                    const buffer = idx > 0 ? (op.timeMinutes - sortedOps[idx-1].timeMinutes) : '-';
                    
                    teamScheduleData.push({
                        'Team': '',
                        'Type': '',
                        'Department': '',
                        'Shift': '',
                        'Operations': '',
                        'Flight': op.flight,
                        'Dest/Origin': op.destination || op.origin || '',
                        'STD/STA': op.time,
                        'Flight Type': op.type,
                        'Gate': op.gate || '',
                        'PAX': op.passengers || '',
                        'Equipment': op.equipment || '',
                        'Operation': isTerminator ? 'STRIP' : 'SERVICE',
                        'Buffer (min)': buffer
                    });
                });
                
                // Blank row between teams
                teamScheduleData.push({});
            });
            
            const teamScheduleSheet = XLSX.utils.json_to_sheet(teamScheduleData);
            teamScheduleSheet['!cols'] = [
                { wch: 10 }, { wch: 6 }, { wch: 12 }, { wch: 14 }, { wch: 10 },
                { wch: 10 }, { wch: 12 }, { wch: 10 }, { wch: 12 }, { wch: 8 },
                { wch: 8 }, { wch: 12 }, { wch: 10 }, { wch: 12 }
            ];
            XLSX.utils.book_append_sheet(wb, teamScheduleSheet, 'Team Schedule');

            // ==================== TAB 3: WORKLOAD ANALYSIS ====================
            const workloadData = sortedTeams.map(tw => {
                const firstFlight = tw.operations[0];
                const lastFlight = tw.operations[tw.operations.length - 1];
                
                // Calculate shift utilization
                const shiftStart = tw.team.startMinutes;
                const shiftEnd = shiftStart + (8.5 * 60);
                let utilizationPercent = 0;
                let finishTime = 'N/A';
                let status = 'Idle';
                
                if (tw.count > 0) {
                    const actualStart = firstFlight.timeMinutes;
                    const serviceTime = (lastFlight.type === 'International' || lastFlight.type === 'Precleared') ? 60 : 40;
                    const actualEnd = lastFlight.timeMinutes + serviceTime + 30;
                    utilizationPercent = Math.round(((actualEnd - actualStart) / (8.5 * 60)) * 100);
                    finishTime = minutesToTime(actualEnd);
                    
                    if (actualEnd <= shiftEnd) {
                        status = 'On Time';
                    } else {
                        status = 'Overtime';
                    }
                }
                
                return {
                    'Team': tw.team.id,
                    'Type': tw.team.type,
                    'Shift Start': tw.team.shift.split('-')[0],
                    'Shift End': minutesToTime(shiftEnd),
                    'Operations': tw.count,
                    'First Flight': firstFlight ? firstFlight.time : '-',
                    'Last Flight': lastFlight ? lastFlight.time : '-',
                    'Finish Time': finishTime,
                    'Status': status,
                    'Utilization %': utilizationPercent,
                    'Domestic': tw.operations.filter(op => op.type === 'Domestic').length,
                    'International': tw.operations.filter(op => op.type === 'International' || op.type === 'Precleared').length,
                    'Terminators': scheduleResult.assignments.filter(a => a.team === tw.team.id && a.operation === 'strip').length
                };
            });
            
            const workloadSheet = XLSX.utils.json_to_sheet(workloadData);
            workloadSheet['!cols'] = [
                { wch: 10 }, { wch: 6 }, { wch: 12 }, { wch: 12 }, { wch: 10 },
                { wch: 12 }, { wch: 12 }, { wch: 12 }, { wch: 10 }, { wch: 12 },
                { wch: 10 }, { wch: 12 }, { wch: 12 }
            ];
            XLSX.utils.book_append_sheet(wb, workloadSheet, 'Workload Analysis');

            // ==================== TAB 4: ALL FLIGHTS (Chronological) ====================
            const allFlightsData = scheduleResult.assignments
                .sort((a, b) => a.flight.timeMinutes - b.flight.timeMinutes)
                .map(a => ({
                    'STD/STA': a.flight.time,
                    'Flight': a.flight.flight,
                    'Origin': a.flight.origin || '',
                    'Destination': a.flight.destination || '',
                    'Type': a.flight.type,
                    'Operation Type': a.flight.operationType || (a.operation === 'strip' ? 'Terminator' : ''),
                    'Gate': a.flight.gate || '',
                    'Terminal': a.flight.gate ? a.flight.gate.charAt(0) : '',
                    'Equipment': a.flight.equipment || '',
                    'PAX': a.flight.passengers || '',
                    'Assigned Team': a.team,
                    'Team Type': scheduleResult.teamWorkload.find(tw => tw.team.id === a.team)?.team.type || '',
                    'Operation': a.operation === 'strip' ? 'STRIP' : 'SERVICE',
                    'Phase': a.phase
                }));
            
            const allFlightsSheet = XLSX.utils.json_to_sheet(allFlightsData);
            allFlightsSheet['!cols'] = [
                { wch: 10 }, { wch: 10 }, { wch: 10 }, { wch: 12 }, { wch: 12 },
                { wch: 14 }, { wch: 8 }, { wch: 10 }, { wch: 12 }, { wch: 8 },
                { wch: 12 }, { wch: 10 }, { wch: 10 }, { wch: 20 }
            ];
            XLSX.utils.book_append_sheet(wb, allFlightsSheet, 'All Flights');

            // ==================== TAB 5: INTERNATIONAL FLIGHTS ====================
            const intlFlights = scheduleResult.assignments
                .filter(a => a.flight.type === 'International' || a.flight.type === 'Precleared')
                .sort((a, b) => a.flight.timeMinutes - b.flight.timeMinutes)
                .map(a => ({
                    'STD': a.flight.time,
                    'Flight': a.flight.flight,
                    'Destination': a.flight.destination,
                    'Type': a.flight.type,
                    'Gate': a.flight.gate || '',
                    'Equipment': a.flight.equipment || '',
                    'PAX': a.flight.passengers || '',
                    'Assigned Team': a.team,
                    'Team Shift': scheduleResult.teamWorkload.find(tw => tw.team.id === a.team)?.team.shift || '',
                    'Phase': a.phase
                }));
            
            const intlSheet = XLSX.utils.json_to_sheet(intlFlights);
            intlSheet['!cols'] = [
                { wch: 10 }, { wch: 10 }, { wch: 15 }, { wch: 12 }, { wch: 8 },
                { wch: 12 }, { wch: 8 }, { wch: 12 }, { wch: 14 }, { wch: 20 }
            ];
            XLSX.utils.book_append_sheet(wb, intlSheet, 'International Flights');

            // ==================== TAB 6: BUFFER VIOLATIONS ====================
            if (scheduleResult.bufferViolations && scheduleResult.bufferViolations.length > 0) {
                const violationsData = scheduleResult.bufferViolations.map(v => ({
                    'Team': v.team,
                    'Flight 1': v.flight1,
                    'Time 1': v.time1,
                    'Type 1': v.type1,
                    'Flight 2': v.flight2,
                    'Time 2': v.time2,
                    'Type 2': v.type2,
                    'Buffer Type': v.bufferType,
                    'Required (min)': v.requiredBuffer,
                    'Actual (min)': v.actualBuffer,
                    'Shortage (min)': v.shortage,
                    'Severity': v.shortage > 30 ? 'HIGH' : v.shortage > 15 ? 'MEDIUM' : 'LOW'
                }));
                
                const violationsSheet = XLSX.utils.json_to_sheet(violationsData);
                violationsSheet['!cols'] = [
                    { wch: 10 }, { wch: 10 }, { wch: 10 }, { wch: 12 }, { wch: 10 },
                    { wch: 10 }, { wch: 12 }, { wch: 12 }, { wch: 12 }, { wch: 12 },
                    { wch: 12 }, { wch: 10 }
                ];
                XLSX.utils.book_append_sheet(wb, violationsSheet, 'Buffer Violations');
            }

            // ==================== TAB 7: UNASSIGNED FLIGHTS ====================
            if (scheduleResult.unassigned && scheduleResult.unassigned.length > 0) {
                const unassignedData = scheduleResult.unassigned.map(u => ({
                    'Flight': u.flight.flight,
                    'Origin': u.flight.origin || '',
                    'Destination': u.flight.destination || '',
                    'STD/STA': u.flight.time,
                    'Type': u.flight.type,
                    'Operation Type': u.flight.operationType || '',
                    'Gate': u.flight.gate || '',
                    'PAX': u.flight.passengers || '',
                    'Reason': u.reason
                }));
                
                const unassignedSheet = XLSX.utils.json_to_sheet(unassignedData);
                unassignedSheet['!cols'] = [
                    { wch: 10 }, { wch: 10 }, { wch: 15 }, { wch: 10 }, { wch: 12 },
                    { wch: 14 }, { wch: 8 }, { wch: 8 }, { wch: 50 }
                ];
                XLSX.utils.book_append_sheet(wb, unassignedSheet, 'Unassigned Flights');
            }

            // ==================== TAB 8: TERMINATOR STRIPS ====================
            const terminatorAssignments = scheduleResult.assignments.filter(a => a.operation === 'strip');
            if (terminatorAssignments.length > 0) {
                const terminatorData = terminatorAssignments
                    .sort((a, b) => a.flight.timeMinutes - b.flight.timeMinutes)
                    .map(a => ({
                        'STA': a.flight.time,
                        'Flight': a.flight.flight,
                        'Origin': a.flight.origin || '',
                        'Gate': a.flight.gate || '',
                        'Equipment': a.flight.equipment || '',
                        'PAX': a.flight.passengers || '',
                        'Assigned Team': a.team,
                        'Team Shift': scheduleResult.teamWorkload.find(tw => tw.team.id === a.team)?.team.shift || '',
                        'Team Operations': scheduleResult.teamWorkload.find(tw => tw.team.id === a.team)?.count || 0
                    }));
                
                const terminatorSheet = XLSX.utils.json_to_sheet(terminatorData);
                terminatorSheet['!cols'] = [
                    { wch: 10 }, { wch: 10 }, { wch: 12 }, { wch: 8 }, { wch: 12 },
                    { wch: 8 }, { wch: 12 }, { wch: 14 }, { wch: 16 }
                ];
                XLSX.utils.book_append_sheet(wb, terminatorSheet, 'Terminator Strips');
            }

            // ==================== TAB 9: IDLE TEAMS ====================
            const idleTeams = sortedTeams.filter(tw => tw.count === 0);
            if (idleTeams.length > 0) {
                const idleTeamsData = idleTeams.map(tw => ({
                    'Team': tw.team.id,
                    'Type': tw.team.type,
                    'Department': tw.team.department,
                    'Shift': tw.team.shift,
                    'Shift Start': tw.team.shift.split('-')[0],
                    'Status': 'IDLE - No Assignments',
                    'Recommendation': 'Consider for sick call coverage or additional terminator strips'
                }));
                
                const idleTeamsSheet = XLSX.utils.json_to_sheet(idleTeamsData);
                idleTeamsSheet['!cols'] = [
                    { wch: 10 }, { wch: 6 }, { wch: 12 }, { wch: 14 }, { wch: 12 },
                    { wch: 25 }, { wch: 50 }
                ];
                XLSX.utils.book_append_sheet(wb, idleTeamsSheet, 'Idle Teams');
            }

            // Save file
            const date = new Date().toISOString().split('T')[0];
            const dayName = scheduleResult.dayOfWeek;
            XLSX.writeFile(wb, `PHL_TRK_Schedule_${dayName}_${date}.xlsx`);
        }
    </script>
</body>
</html>
